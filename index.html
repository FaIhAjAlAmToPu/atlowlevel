<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>asm</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/black.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css">
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<section>
					<h3>Basic Components of a Computer System</h3>
				</section>

				<section>
					<div style="margin-top: 60px; position: relative; width: 900px; height: 500px; margin: 0 auto;">

						<!-- CPU -->
						<div class="fragment fade-in"
							style="position: absolute; top: 40px; left: 100px; width: 150px; height: 70px; border: 2px solid #00bfff; background: rgba(0,191,255,0.2); display: flex; align-items: center; justify-content: center;">
							CPU
						</div>

						<!-- Memory -->
						<div class="fragment fade-in"
							style="position: absolute; top: 40px; right: 20px; width: 150px; height: 70px; border: 2px solid #ff9800; background: rgba(255,152,0,0.2); display: flex; align-items: center; justify-content: center;">
							Memory
						</div>

						<!-- I/O -->
						<div class="fragment fade-in"
							style="position: absolute; bottom: 00px; left: 370px; width: 160px; height: 70px; border: 2px solid #4caf50; background: rgba(76,175,80,0.2); display: flex; align-items: center; justify-content: center;">
							I/O
						</div>

						<!-- Interconnect (Bus System) -->
						<div class="fragment fade-in"
							style="position: absolute; top: 150px; left: 250px; width: 400px; height: 200px; border-radius: 50%; border: 2px solid #888; background: rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: center;">
							<b>Interconnect</b><br><span style="font-size:0.8em;">(System Bus)</span>
						</div>

						<!-- Connecting Lines -->
						<svg class="fragment fade-in" width="900" height="500" style="position:absolute;top:0;left:0;">
							<!-- CPU to Interconnect -->
							<line x1="175" y1="75" x2="450" y2="250" stroke="white" stroke-width="2" />

							<!-- Memory to Interconnect -->
							<line x1="805" y1="75" x2="450" y2="250" stroke="white" stroke-width="2" />

							<!-- I/O to Interconnect -->
							<line x1="450" y1="465" x2="450" y2="250" stroke="white" stroke-width="2" />
						</svg>

					</div>

					<p class="fragment fade-up" style="margin-top: 50px; font-size: 0.9em;">
						A computer system consists of <b>CPU</b>, <b>Memory</b>, and <b>Input/Output</b> devices, all
						connected by an <b>Interconnect (System Bus)</b>.
					</p>
				</section>

				<!-- Explanation -->
				<section>
					<h3>Component Roles</h3>
					<ul>
						<li class="fragment fade-in"><b>CPU:</b> Executes instructions and controls operations.</li>
						<li class="fragment fade-in"><b>Memory:</b> Stores programs and data.</li>
						<li class="fragment fade-in"><b>Input/Output:</b> Communicates with external devices.</li>
						<li class="fragment fade-in"><b>Interconnect (Bus):</b> Transfers data and control signals
							between components.</li>
					</ul>
					<p class="fragment fade-up" style="color:#0dcaf0;margin-top:15px;">
						Together, these form the backbone of all computer operations.
					</p>
				</section>
			</section>

			<section>
				<section>
					<h3>Instruction Execution Cycle</h3>

					<div style="margin-top: 40px; position: relative; width: 900px; height: 180px; margin: 0 auto;">

						<!-- Timeline Arrow -->
						<div
							style="position: absolute; top: 110px; left: 0; width: 1020px; height: 2px; background: white;">
						</div>
						<div
							style="position: absolute; top: 104px; left: 1020px; width: 0; height: 0; border-top: 6px solid transparent; border-bottom: 6px solid transparent; border-left: 10px solid white;">
						</div>
						<div style="position: absolute; top: 125px; left: 500px; font-size: 0.9em;">time ‚Üí</div>

						<!-- Instruction Boxes (spaced properly) -->
						<div class="fragment"
							style="position: absolute; top: 30px; left: 0; width: 120px; height: 60px; border: 2px solid white; background: rgba(0,123,255,0.3); display: flex; align-items: center; justify-content: center;">
							Fetch</div>

						<div class="fragment"
							style="position: absolute; top: 30px; left: 140px; width: 140px; height: 60px; border: 2px solid white; background: rgba(255,165,0,0.3); display: flex; align-items: center; justify-content: center;">
							Decode</div>

						<div class="fragment"
							style="position: absolute; top: 30px; left: 300px; width: 150px; height: 60px; border: 2px solid white; background: rgba(50,205,50,0.3); display: flex; align-items: center; justify-content: center;">
							Execute</div>

						<div class="fragment"
							style="position: absolute; top: 30px; left: 470px; width: 120px; height: 60px; border: 2px solid white; background: rgba(0,123,255,0.3); display: flex; align-items: center; justify-content: center;">
							Fetch</div>

						<div class="fragment"
							style="position: absolute; top: 30px; left: 610px; width: 140px; height: 60px; border: 2px solid white; background: rgba(255,165,0,0.3); display: flex; align-items: center; justify-content: center;">
							Decode</div>

						<div class="fragment"
							style="position: absolute; top: 30px; left: 770px; width: 150px; height: 60px; border: 2px solid white; background: rgba(50,205,50,0.3); display: flex; align-items: center; justify-content: center;">
							Execute</div>

						<!-- Continuation Dots -->
						<div class="fragment fade-in"
							style="position: absolute; top: 10px; left: 950px; font-size: 2em;">
							...</div>
					</div>

					<p class="fragment fade-in" style="margin-top: 120px; font-size: 0.9em;">
						Each instruction passes through <b>Fetch ‚Üí Decode ‚Üí Execute</b> stages repeatedly.<br>
						This continuous process is known as the <b>Instruction Execution Cycle</b>.
					</p>
				</section>
				<!-- FETCH -->
				<section data-auto-animate>
					<h3>Fetch Phase</h3>
					<p class="fragment fade-in"><b>Goal:</b> Get the next instruction from memory</p>
					<ul style="font-size:0.95em;">
						<li class="fragment fade-in">Address placed on <b>Address Bus</b></li>
						<li class="fragment fade-in">Memory <b>Read</b> signal activated</li>
						<li class="fragment fade-in">Memory sends instruction via <b>Data Bus</b></li>
						<li class="fragment fade-in">CPU stores it in the <b>Instruction Register</b></li>
					</ul>
					<p class="fragment fade-up" style="color:#0dcaf0;">üïê Access Time ‚Üí Delay to fetch data</p>
				</section>

				<!-- DECODE -->
				<section data-auto-animate>
					<h3>Decode Phase</h3>
					<p class="fragment fade-in"><b>Goal:</b> Understand what to do</p>
					<ul style="font-size:0.95em;">
						<li class="fragment fade-in"><b>Control Unit</b> interprets the binary instruction</li>
						<li class="fragment fade-in">Extracts <b>Opcode</b> and <b>Operands</b></li>
						<li class="fragment fade-in">Prepares signals for the next step</li>
					</ul>
					<p class="fragment fade-up" style="color:#ffc107;">üîç Decode ‚Üí Identify operation + data</p>
				</section>

				<!-- EXECUTE -->
				<section data-auto-animate>
					<h3>Execute Phase</h3>
					<p class="fragment fade-in"><b>Goal:</b> Perform the operation</p>
					<ul style="font-size:0.95em;">
						<li class="fragment fade-in"><b>ALU</b> performs arithmetic or logic tasks</li>
						<li class="fragment fade-in"><b>Control Circuits</b> manage timing and signals</li>
						<li class="fragment fade-in">Result ‚Üí stored in <b>Register</b> or <b>Memory</b></li>
					</ul>
					<p class="fragment fade-up" style="color:#28a745;">‚öôÔ∏è Execute ‚Üí Action happens!</p>
				</section>

				<!-- CACHE -->
				<section data-auto-animate>
					<h3>Cache Memory</h3>
					<ul style="font-size:0.95em;">
						<li class="fragment fade-in"><b>Cache</b> = high-speed memory close to CPU</li>
						<li class="fragment fade-in">Stores recently used <b>instructions</b> & <b>data</b></li>
						<li class="fragment fade-in">Reduces access delay from main memory</li>
						<li class="fragment fade-in">Boosts <b>CPU performance</b></li>
					</ul>
					<p class="fragment fade-up" style="color:#20c997;">‚ö° Faster fetch ‚Üí faster execution</p>
				</section>

				<!-- SUMMARY -->
				<section>
					<h3>Cycle Recap</h3>
					<div style="display:flex; justify-content:center; align-items:center; gap:20px;">
						<div class="fragment fade-in"
							style="padding:15px 25px; border:2px solid #007bff; background:rgba(0,123,255,0.3); border-radius:10px;">
							Fetch</div>
						<div class="fragment fade-in"
							style="padding:15px 25px; border:2px solid #ffa500; background:rgba(255,165,0,0.3); border-radius:10px;">
							Decode</div>
						<div class="fragment fade-in"
							style="padding:15px 25px; border:2px solid #28a745; background:rgba(40,167,69,0.3); border-radius:10px;">
							Execute</div>
						<div class="fragment fade-in" style="font-size:2em;">‚Üí ...</div>
					</div>
					<p class="fragment fade-up" style="margin-top:30px; font-size:0.9em;">
						<b>Instruction Cycle:</b> Repeats endlessly ‚Äî Fetch, Decode, Execute.<br>
						<b>Cache</b> keeps it all running fast ‚ö°
					</p>
				</section>
			</section>
			<section>
				<!-- Introduction to Address Machines -->
				<section>
					<h3>Address Machines</h3>
					<p class="fragment fade-in" style="font-size:0.9em;">
						Computer architectures use different instruction formats based on the number of operands, known
						as <b>address machines</b>.
					</p>
					<ul style="font-size:0.95em;">
						<li class="fragment fade-in">Classified as 3-address, 2-address, 1-address, or 0-address
							machines.</li>
						<li class="fragment fade-in">Each type affects how instructions are written and executed in a
							CPU (e.g., Pentium).</li>
						<li class="fragment fade-in">We‚Äôll evaluate the expression <code>A * B - C + D/E + F</code> for
							each type.</li>
					</ul>
					<p class="fragment fade-up" style="color:#0dcaf0;margin-top:15px;">
						üõ†Ô∏è Understanding address machines helps in compiler design and assembly programming.
					</p>
				</section>

				<!-- 3-Address Machine Overview -->
				<section>
					<h3>3-Address Machine</h3>
					<p class="fragment fade-in" style="font-size:0.9em;">
						<b>Architecture Overview:</b> Instructions have three operands:
						<code>OP Dest, Src1, Src2</code>.
						Result is stored in a separate register.
					</p>
					<ul style="font-size:0.85em;">
						<li class="fragment fade-in">Common in RISC architectures (e.g., MIPS, emulated in Pentium).
						</li>
						<li class="fragment fade-in">Uses registers (e.g., EAX, EBX) for fast computation.</li>
						<li class="fragment fade-in">Memory variables (e.g., A, B) are loaded into registers first.</li>
					</ul>
				</section>

				<!-- 3-Address Machine Example -->
				<section data-auto-animate>
					<h3>3-Address Machine Example</h3>
					<pre class="fragment fade-in" style="font-size:0.7em;"><code class="language-asm">
MOV T1, A
MOV T2, B
MUL T3, T1, T2
MOV T1, C
SUB T2, T3, T1
MOV T3, D
MOV T1, E
DIV T4, T3, T1
ADD T3, T2, T4
MOV T1, F
ADD T2, T3, T1
    </code></pre>
					<p class="fragment fade-up" style="color:#007bff;">‚öôÔ∏è Result in T2. Uses 4 registers, explicit
						operands.</p>
				</section>

				<section>
					<h3>3-Address Machine Example</h3>
					<pre class="fragment fade-in" style="font-size:0.7em;"><code class="language-asm">
lw $t0, A    # Load A from memory into $t0
lw $t1, B    # Load B from memory into $t1
mul $t2, $t0, $t1  # Multiply $t0 and $t1, store result in $t2 (A * B)
lw $t0, C    # Load C from memory into $t0
sub $t3, $t2, $t0  # Subtract $t0 from $t2, store result in $t3 (A * B - C)
lw $t0, D    # Load D from memory into $t0
lw $t1, E    # Load E from memory into $t1
div $t4, $t0, $t1  # Divide $t0 by $t1, store quotient in $t4 (D / E)
add $t3, $t3, $t4  # Add $t4 to $t3, store result in $t3 (A * B - C + D/E)
lw $t0, F    # Load F from memory into $t0
add $t2, $t3, $t0  # Add $t0 to $t3, store result in $t2 (A * B - C + D/E + F)
sw $t2, result    # Store final result in memory location 'result'
</code></pre>
				</section>

				<!-- 2-Address Machine Overview -->
				<section>
					<h3>2-Address Machine</h3>
					<p class="fragment fade-in" style="font-size:0.9em;">
						<b>Architecture Overview:</b> Instructions have two operands: <code>OP Dest, Src</code>. Result
						overwrites the destination operand.
					</p>
					<ul style="font-size:0.85em;">
						<li class="fragment fade-in">Common in CISC architectures like Pentium (e.g., x86 MOV, ADD).
						</li>
						<li class="fragment fade-in">Requires initial load (MOV) to set up operands.</li>
						<li class="fragment fade-in">Fewer registers needed, but more instructions.</li>
					</ul>
				</section>

				<!-- 2-Address Machine Example -->
				<section data-auto-animate>
					<h3>2-Address Machine Example</h3>
					<pre class="fragment fade-in" style="font-size:0.7em;"><code class="language-asm">
MOV T1, A
MUL T1, B
SUB T1, C
MOV T2, D
DIV T2, E
ADD T1, T2
ADD T1, F
    </code></pre>
					<p class="fragment fade-up" style="color:#ffa500;">‚öôÔ∏è Result in T1. Reuses registers, overwrites
						operands.</p>
				</section>

				<!-- 1-Address Machine Overview -->
				<section>
					<h3>1-Address Machine</h3>
					<p class="fragment fade-in" style="font-size:0.9em;">
						<b>Architecture Overview:</b> Uses a single accumulator for operations: <code>OP Src</code>.
						Accumulator holds one operand and result.
					</p>
					<ul style="font-size:0.85em;">
						<li class="fragment fade-in">Seen in early computers, emulated in Pentium via EAX.</li>
						<li class="fragment fade-in">Operations like LOAD, STORE manage accumulator.</li>
						<li class="fragment fade-in">Simplifies hardware but increases instructions.</li>
					</ul>
				</section>

				<!-- 1-Address Machine Example -->
				<section data-auto-animate>
					<h3>1-Address Machine Example</h3>
					<pre class="fragment fade-in" style="font-size:0.7em;"><code class="language-asm">
LOAD A
MUL B
SUB C
STORE T1
LOAD D
DIV E
ADD T1
ADD F
STORE T2
    </code></pre>
					<p class="fragment fade-up" style="color:#28a745;">‚öôÔ∏è Result in T2. Accumulator-centric, minimal
						registers.</p>
				</section>

				<!-- 0-Address Machine Overview -->
				<section>
					<h3>0-Address Machine</h3>
					<p class="fragment fade-in" style="font-size:0.9em;">
						<b>Architecture Overview:</b> Stack-based, operations use top stack elements: <code>OP</code>.
						No explicit operands in instructions.
					</p>
					<ul style="font-size:0.85em;">
						<li class="fragment fade-in">Used in stack machines (e.g., Java VM, some FPU in Pentium).</li>
						<li class="fragment fade-in">PUSH loads data, POP stores results.</li>
						<li class="fragment fade-in">Operations pop operands, push results.</li>
					</ul>
				</section>

				<!-- 0-Address Machine Example -->
				<section data-auto-animate>
					<h3>0-Address Machine Example</h3>
					<pre class="fragment fade-in" style="font-size:0.7em;"><code class="language-asm">
PUSH A
PUSH B
MUL
PUSH C
SUB
PUSH D
PUSH E
DIV
ADD
PUSH F
ADD
POP T1
    </code></pre>
					<p class="fragment fade-up" style="color:#20c997;">‚öôÔ∏è Result in T1. Stack-based, no explicit
						operands.</p>
				</section>

				<!-- Summary -->
				<section>
					<h3>Address Machines Summary</h3>
					<div style="display:flex; justify-content:center; align-items:center; gap:20px; flex-wrap:wrap;">
						<div class="fragment fade-in"
							style="padding:10px 20px; border:2px solid #007bff; background:rgba(0,123,255,0.3); border-radius:10px;">
							3-Address: Explicit operands
						</div>
						<div class="fragment fade-in"
							style="padding:10px 20px; border:2px solid #ffa500; background:rgba(255,165,0,0.3); border-radius:10px;">
							2-Address: Overwrite operand
						</div>
						<div class="fragment fade-in"
							style="padding:10px 20px; border:2px solid #28a745; background:rgba(40,167,69,0.3); border-radius:10px;">
							1-Address: Accumulator
						</div>
						<div class="fragment fade-in"
							style="padding:10px 20px; border:2px solid #20c997; background:rgba(32,201,151,0.3); border-radius:10px;">
							0-Address: Stack-based
						</div>
					</div>
					<p class="fragment fade-up" style="margin-top:30px; font-size:0.9em;">
						Each machine type balances <b>instruction complexity</b> and <b>hardware simplicity</b>.<br>
						Pentium uses a mix, primarily 2-address with 3-address emulation.
					</p>
				</section>
			</section>

			<section>
				<section>
					<h2>Pentium Processor</h2>
					<p>The Intel Pentium is a fifth-generation x86 microprocessor architecture introduced in 1993.</p>
				</section>

				<section>
					<h3>Why Study the Pentium Processor?</h3>
					<ul>
						<li class="fragment">Introduced <strong>superscalar architecture</strong> ‚Äî two instructions per
							clock</li>
						<li class="fragment">Illustrates key concepts like <em>pipelining</em>, <em>branch
								prediction</em>, and <em>caching</em></li>
					</ul>
				</section>

				<section>
					<h3>Superscalar Processor (Pentium)</h3>

					<p class="fragment fade-in">
						A <strong>superscalar processor</strong> can perform <strong>more than one instruction</strong>
						in the same clock cycle.
					</p>

					<div class="fragment fade-in">
						<table style="margin:auto; border-collapse:collapse; border:2px solid #ccc;">
							<tr>
								<th style="padding:8px; border:2px solid #ccc;">Processor Type</th>
								<th style="padding:8px; border:2px solid #ccc;">Instructions per Clock</th>
							</tr>
							<tr>
								<td style="padding:8px; border:2px solid #ccc;">Scalar (e.g., 80486)</td>
								<td style="padding:8px; border:2px solid #ccc;">1 instruction</td>
							</tr>
							<tr>
								<td style="padding:8px; border:2px solid #ccc;">Superscalar (e.g., Pentium)</td>
								<td style="padding:8px; border:2px solid #ccc;">2 or more instructions</td>
							</tr>
						</table>

					</div>

					<p class="fragment fade-in">
						Pentium uses two pipelines ‚Äî <strong>U-pipe</strong> and <strong>V-pipe</strong> ‚Äî
						so it can execute <em>two independent instructions</em> in parallel.
					</p>

					<pre class="fragment"><code class="language-asm" data-trim>
; Example
MOV EAX, [A]    ; U-pipe
ADD EBX, [B]    ; V-pipe
  </code></pre>
				</section>

				<section>
					<h3>Superscalar Pipeline Flow</h3>
					<p class="fragment fade-in">Two pipelines (U-pipe & V-pipe) execute independent instructions in
						parallel.</p>

					<div style="display:flex; gap:30px; margin-top:20px;" class="fragment fade-in">

						<!-- Left: Code -->
						<div style="flex:1;">
							<pre style="font-family: monospace; font-size:16px;"><code>
1. MOV EAX, [A]
2. ADD EBX, [B]
3. SUB ECX, EDX
4. MUL EAX, ECX
5. MOV ESI, [X]
6. ADD EDI, [Y]
      </code></pre>
						</div>

						<!-- Right: Pipeline Flow -->
						<div style="flex:1; font-family: monospace;">
							<div
								style="display:grid; grid-template-columns: repeat(7, 80px); text-align:center; gap:5px;">
								<!-- Header -->
								<div style="font-weight:bold;">Clk</div>
								<div style="font-weight:bold;">1</div>
								<div style="font-weight:bold;">2</div>
								<div style="font-weight:bold;">3</div>
								<div style="font-weight:bold;">4</div>
								<div style="font-weight:bold;">5</div>
								<div style="font-weight:bold;">6</div>

								<!-- U-pipe -->
								<div style="font-weight:bold;">U</div>
								<div style="background:#00BFFF; color:white; padding:5px; border-radius:3px;">MOV</div>
								<div style="background:#00BFFF; color:white; padding:5px; border-radius:3px;">SUB</div>
								<div style="background:#00BFFF; color:white; padding:5px; border-radius:3px;">MOV</div>
								<div></div>
								<div></div>
								<div></div>

								<!-- V-pipe -->
								<div style="font-weight:bold;">V</div>
								<div style="background:#FF69B4; color:white; padding:5px; border-radius:3px;">ADD</div>
								<div></div>
								<div style="background:#FF69B4; color:white; padding:5px; border-radius:3px;">MUL</div>
								<div style="background:#FF69B4; color:white; padding:5px; border-radius:3px;">ADD</div>
								<div></div>
								<div></div>
							</div>
						</div>


					</div>

					<p class="fragment fade-in" style="margin-top:10px;">
						‚úÖ Two instructions per cycle in parallel (U + V).
						‚ö†Ô∏è Dependent instructions must wait for previous results.
					</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Pentium / Pentium Pro Processor</h2>
					<p>The Pentium and Pentium Pro processor has three operating modes:</p>
				</section>

				<!-- Slide 2: Real-Address Mode -->
				<section>
					<h2>Real-Address Mode</h2>
					<ul>
						<li>Processor addresses "real" memory addresses (20-bit address, up to 1MB memory)</li>
						<li>Also called "unprotected mode" because OS and applications run in the same mode</li>
						<li>Processor starts in this mode on power-up or reset</li>
					</ul>
				</section>

				<!-- Slide 3: Protected Mode -->
				<section>
					<h2>Protected Mode</h2>
					<ul>
						<li>Preferred mode for modern operating systems</li>
						<li>Supports virtual memory addressing</li>
						<li>Allows multiple programming environments and protections</li>
					</ul>
				</section>

				<!-- Slide 4: System Management Mode -->
				<section>
					<h2>System Management Mode (SMM)</h2>
					<ul>
						<li>Designed for fast state snapshot and resumption</li>
						<li>Useful for power management</li>
					</ul>
				</section>
			</section>


			<section>
				<section>
					<h2>What is a Register?</h2>
					<ul style="font-size:1.2em; line-height:1.8;">
						<li>Small, fast storage inside the CPU</li>
						<li>Holds data, instructions, addresses, or intermediate results</li>
						<li>Much faster than RAM</li>
					</ul>
				</section>
				<section>
					<h3>Pentium Register Set</h3>
					<p>
						There are three types of registers: general-purpose data registers, segment registers,
						and status/control registers.
					</p>
				</section>

				<section>
					<h3>Pentium Register Set</h3>

					<div style="
      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap:25px;
      margin-top:15px;
      flex-wrap:wrap;
      font-family:monospace;
      max-width:900px;
      margin-left:auto;
      margin-right:auto;
    ">

						<!-- General-purpose registers -->
						<div style="width:230px; text-align:center;">
							<h4 style="margin-bottom:4px;">General-purpose registers</h4>
							<div
								style="display:flex; justify-content:space-between; font-size:13px; margin-bottom:3px;">
								<span>31</span><span>0</span>
							</div>
							<div style="border:1.2px solid #000; border-radius:4px; overflow:hidden; font-size:15px;">
								<div style="border-bottom:1px solid #000; padding:3px;">EAX</div>
								<div style="border-bottom:1px solid #000; padding:3px;">EBX</div>
								<div style="border-bottom:1px solid #000; padding:3px;">ECX</div>
								<div style="border-bottom:1px solid #000; padding:3px;">EDX</div>
								<div style="border-bottom:1px solid #000; padding:3px;">ESI</div>
								<div style="border-bottom:1px solid #000; padding:3px;">EDI</div>
								<div style="border-bottom:1px solid #000; padding:3px;">EBP</div>
								<div style="padding:3px;">ESP</div>
							</div>
						</div>

						<!-- Segment registers -->
						<div style="width:200px; text-align:center;">
							<h4 style="margin-bottom:4px;">Segment registers</h4>
							<div
								style="display:flex; justify-content:space-between; font-size:13px; margin-bottom:3px;">
								<span>15</span><span>0</span>
							</div>
							<div style="border:1.2px solid #000; border-radius:4px; overflow:hidden; font-size:15px;">
								<div style="border-bottom:1px solid #000; padding:3px;">CS</div>
								<div style="border-bottom:1px solid #000; padding:3px;">DS</div>
								<div style="border-bottom:1px solid #000; padding:3px;">SS</div>
								<div style="border-bottom:1px solid #000; padding:3px;">ES</div>
								<div style="border-bottom:1px solid #000; padding:3px;">FS</div>
								<div style="padding:3px;">GS</div>
							</div>
						</div>

						<!-- Status and control registers -->
						<div style="width:220px; text-align:center;">
							<h4 style="margin-bottom:4px;">Status and control registers</h4>
							<div
								style="display:flex; justify-content:space-between; font-size:13px; margin-bottom:3px;">
								<span>31</span><span>0</span>
							</div>
							<div style="border:1.2px solid #000; border-radius:4px; overflow:hidden; font-size:15px;">
								<div style="border-bottom:1px solid #000; padding:3px;">EFLAGS</div>
								<div style="padding:3px;">EIP</div>
							</div>
						</div>
					</div>

					<p class="fragment fade-in" style="margin-top:18px; text-align:center;">
						These registers enable efficient data handling and instruction execution
						in the Pentium‚Äôs dual pipelines.
					</p>
				</section>






				<section>
					<h3>Understanding Pentium Registers</h3>
					<ul>
						<li class="fragment">General-purpose (EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP): Handle data and
							addresses; EAX for results, ESP/EBP for stack management in pipelines.</li>
						<li class="fragment">Segment (CS, DS, SS, ES, FS, GS): Define memory segments for protected
							mode, supporting parallel memory access.</li>
						<li class="fragment">Status/Control (EFLAGS, EIP): EFLAGS tracks operation status; EIP points to
							the next instruction, critical for pipeline flow.</li>
					</ul>
					<p class="fragment fade-in">Why different? Specialized registers optimize the Pentium‚Äôs superscalar
						design, reducing dependencies and enhancing parallel execution efficiency.</p>
				</section>

				<!-- Slide 1: General-purpose registers -->
				<section>
					<h3>General-Purpose Registers (31‚Äì0)</h3>

					<div style="
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:monospace;
      margin-top:20px;
    ">
						<div
							style="border:1.5px solid #000; border-radius:4px; overflow:hidden; font-size:18px; width:260px; text-align:center;">
							<div style="border-bottom:1px solid #000; padding:6px;">EAX</div>
							<div style="border-bottom:1px solid #000; padding:6px;">EBX</div>
							<div style="border-bottom:1px solid #000; padding:6px;">ECX</div>
							<div style="border-bottom:1px solid #000; padding:6px;">EDX</div>
							<div style="border-bottom:1px solid #000; padding:6px;">ESI</div>
							<div style="border-bottom:1px solid #000; padding:6px;">EDI</div>
							<div style="border-bottom:1px solid #000; padding:6px;">EBP</div>
							<div style="padding:6px;">ESP</div>
						</div>
						<p class="fragment fade-in" style="margin-top:20px; text-align:center; font-size:18px;">
							These are 32-bit data registers used for arithmetic, logic, and data transfer operations.
						</p>
					</div>
				</section>

				<section>
					<h3>Example: General-Purpose Register Usage</h3>

					<div style="
      display:flex;
      justify-content:center;
      align-items:flex-start;
      gap:40px;
      margin-top:25px;
      flex-wrap:wrap;
      font-family:monospace;
    ">

						<!-- Left: Assembly Code -->
						<div style="flex:1; min-width:320px; max-width:400px;">
							<pre style="
          font-family:monospace;
          font-size:18px;
          border:1.5px solid #000;
          border-radius:6px;
          padding:12px;
          line-height:1.5em;
          background:transparent;
        "><code>
; Arithmetic operations
MOV  EAX, 10      ; Load 10 into EAX
MOV  EBX, 20      ; Load 20 into EBX
ADD  EAX, EBX     ; EAX = EAX + EBX ‚Üí 30
MOV  ECX, EAX     ; Copy result to ECX
SUB  ECX, 5       ; ECX = ECX - 5 ‚Üí 25
        </code></pre>
						</div>

						<!-- Right: Explanation -->
						<div style="flex:1; min-width:300px; max-width:380px; font-size:18px;">
							<ul style="list-style-type:none; padding-left:0;">
								<li><b>EAX</b> ‚Äì Accumulator for arithmetic results</li>
								<li><b>EBX</b> ‚Äì Holds second operand (20)</li>
								<li><b>ECX</b> ‚Äì Used here to hold the final result (25)</li>
								<li><b>EDX</b> ‚Äì Often used in multiplication/division (not used here)</li>
							</ul>
							<p class="fragment fade-in" style="margin-top:10px;">
								These 32-bit registers allow arithmetic, data movement, and loop control efficiently in
								Pentium processors.
							</p>
						</div>

					</div>
				</section>



				<!-- Slide 2: Segment registers -->
				<section>
					<h3>Segment Registers (15‚Äì0)</h3>

					<div style="
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:monospace;
      margin-top:20px;
    ">
						<div
							style="border:1.5px solid #000; border-radius:4px; overflow:hidden; font-size:18px; width:220px; text-align:center;">
							<div style="border-bottom:1px solid #000; padding:6px;">CS</div>
							<div style="border-bottom:1px solid #000; padding:6px;">DS</div>
							<div style="border-bottom:1px solid #000; padding:6px;">SS</div>
							<div style="border-bottom:1px solid #000; padding:6px;">ES</div>
							<div style="border-bottom:1px solid #000; padding:6px;">FS</div>
							<div style="padding:6px;">GS</div>
						</div>
						<p class="fragment fade-in" style="margin-top:20px; text-align:center; font-size:18px;">
							These define segments in memory for code, data, and stack addressing in real and protected
							modes.
						</p>
					</div>
				</section>

				<section>
					<h3>Pentium Memory Segmentation</h3>

					<p style="text-align:center; font-size:18px;">
						The Pentium processor divides memory into logical segments to efficiently manage code,
						data, and stack in protected mode.
					</p>

					<div style="
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap:20px;
      margin-top:25px;
      font-size:17px;
      text-align:center;
    ">

						<div style="border:1.5px solid #000; border-radius:8px; padding:10px;">
							<b>Code Segment</b><br>
							Contains executable instructions. The processor fetches instructions from this segment
							using the <b>CS</b> register.
						</div>

						<div style="border:1.5px solid #000; border-radius:8px; padding:10px;">
							<b>Data Segment</b><br>
							Holds global and static variables used by programs. Accessed through <b>DS</b>.
						</div>

						<div style="border:1.5px solid #000; border-radius:8px; padding:10px;">
							<b>Stack Segment</b><br>
							Stores function parameters, local variables, and return addresses. Managed via <b>SS</b>.
						</div>

						<div style="border:1.5px solid #000; border-radius:8px; padding:10px;">
							<b>Extra Segment(s)</b><br>
							Additional data areas (e.g., <b>ES, FS, GS</b>) used for string, thread, or system-level
							operations.
						</div>

						<div style="border:1.5px solid #000; border-radius:8px; padding:10px;">
							<b>System Segments</b><br>
							Contain system-level structures such as the <b>Global Descriptor Table (GDT)</b>
							and <b>Local Descriptor Table (LDT)</b>.
						</div>

					</div>

					<p class="fragment fade-in" style="margin-top:20px; text-align:center; font-size:18px;">
						Each segment has a descriptor defining its base address, size, and access rights,
						allowing isolation and protection in Pentium‚Äôs protected mode.
					</p>
				</section>



				<!-- Slide 3: Status and control registers -->
				<section>
					<h3>Status and Control Registers</h3>

					<div style="
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      font-family:monospace;
      margin-top:20px;
    ">
						<div
							style="border:1.5px solid #000; border-radius:4px; overflow:hidden; font-size:18px; width:240px; text-align:center;">
							<div style="border-bottom:1px solid #000; padding:6px;">EFLAGS</div>
							<div style="padding:6px;">EIP</div>
						</div>
						<p class="fragment fade-in" style="margin-top:20px; text-align:center; font-size:18px;">
							<b>EIP</b> holds the next instruction address, while <b>EFLAGS</b> stores condition and
							control bits for the processor.
						</p>
					</div>
				</section>


				<!-- Slide 1: Introduction -->
				<section>
					<h3>Pentium Segment Registers</h3>
					<p>Segment registers in Pentium are used to access different memory segments: CS, DS, SS, ES, FS,
						GS.</p>
				</section>

				<!-- Slide 2: Data Segment (DS) -->
				<section>
					<h3>Data Segment (DS)</h3>
					<div style="display:flex; justify-content:space-between;">
						<pre style="margin:0;">
MOV AX, 0x1000   ; Load segment value
MOV DS, AX       ; Set DS register
MOV AX, [VAR1]   ; Access variable in DS segment
    </pre>
						<pre style="margin:0;">
; DS points to data segment
; Allows access to variables like VAR1
; Essential for memory operations
    </pre>
					</div>
				</section>

				<!-- Slide 3: Extra Segment (ES) -->
				<section>
					<h3>Extra Segment (ES)</h3>
					<div style="display:flex; justify-content:space-between;">
						<pre style="margin:0;">
MOV AX, 0x2000
MOV ES, AX       ; Set ES register
MOV [ES:VAR2], AX ; Store AX into ES segment variable
    </pre>
						<pre style="margin:0;">
; ES is often used for string operations
; Example: MOVS, STOS instructions
; Allows memory access in another segment
    </pre>
					</div>
				</section>

				<!-- Slide 4: Stack Segment (SS) -->
				<section>
					<h3>Stack Segment (SS)</h3>
					<div style="display:flex; justify-content:space-between;">
						<pre style="margin:0;">
MOV AX, 0x3000
MOV SS, AX       ; Set stack segment
MOV SP, 0xFFFE   ; Initialize stack pointer
PUSH AX
POP BX
    </pre>
						<pre style="margin:0;">
; SS defines stack memory
; SP points to top of stack
; Push/Pop automatically use SS
    </pre>
					</div>
				</section>

				<!-- Slide 5: Code Segment (CS) -->
				<section>
					<h3>Code Segment (CS)</h3>
					<div style="display:flex; justify-content:space-between;">
						<pre style="margin:0;">
MOV AX, 0x4000
MOV CS, AX       ; Set code segment (restricted in real mode)
CALL PROC1       ; Jump to code in new segment
    </pre>
						<pre style="margin:0;">
; CS points to code segment
; Normally set at program start
; Used for instruction fetch
    </pre>
					</div>
				</section>

				<!-- Slide 6: FS and GS -->
				<section>
					<h3>FS & GS Registers</h3>
					<div style="display:flex; justify-content:space-between;">
						<pre style="margin:0;">
MOV AX, 0x5000
MOV FS, AX       ; User-defined segment
MOV AX, 0x6000
MOV GS, AX       ; Another user-defined segment
    </pre>
						<pre style="margin:0;">
; FS and GS can store thread-local or special data
; Useful in modern OS for segment-based addressing
    </pre>
					</div>
				</section>


			</section>

			<section>
				<section>
					<h1>Protected Mode Overview</h1>
				</section>

				<section>
					<h2 style="color:#58a6ff;">Two-Level Address Translation (32-bit x86)</h2>

					<svg width="900" height="300" viewBox="0 0 900 300" xmlns="http://www.w3.org/2000/svg">
						<!-- Arrows and boxes -->
						<defs>
							<marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
								<path d="M0,0 L0,6 L9,3 z" fill="#58a6ff" />
							</marker>
						</defs>

						<!-- Left box -->
						<rect x="150" y="80" width="180" height="120" rx="8" fill="none" stroke="#58a6ff"
							stroke-width="3" />
						<text x="240" y="120" text-anchor="middle" fill="white" font-size="24"
							font-family="Arial">Segment</text>
						<text x="240" y="155" text-anchor="middle" fill="white" font-size="24"
							font-family="Arial">translation</text>

						<!-- Right box -->
						<rect x="470" y="80" width="180" height="120" rx="8" fill="none" stroke="#58a6ff"
							stroke-width="3" />
						<text x="550" y="120" text-anchor="middle" fill="white" font-size="24"
							font-family="Arial">Page</text>
						<text x="550" y="155" text-anchor="middle" fill="white" font-size="24"
							font-family="Arial">translation</text>

						<!-- Arrows -->
						<line x1="80" y1="140" x2="150" y2="140" stroke="#58a6ff" stroke-width="4"
							marker-end="url(#arrow)" />
						<line x1="330" y1="140" x2="470" y2="140" stroke="#58a6ff" stroke-width="4"
							marker-end="url(#arrow)" />
						<line x1="650" y1="140" x2="750" y2="140" stroke="#58a6ff" stroke-width="4"
							marker-end="url(#arrow)" />

						<!-- Labels -->
						<text x="0" y="135" fill="#8b949e" font-size="22" font-family="Arial">Logical</text>
						<text x="0" y="160" fill="#8b949e" font-size="22" font-family="Arial">address</text>

						<text x="350" y="70" fill="#58a6ff" font-size="24" font-family="Arial"
							font-weight="bold">32-bit</text>
						<text x="350" y="100" fill="#8b949e" font-size="22" font-family="Arial">linear</text>
						<text x="350" y="130" fill="#8b949e" font-size="22" font-family="Arial">address</text>

						<text x="760" y="125" fill="#8b949e" font-size="22" font-family="Arial">32-bit</text>
						<text x="760" y="150" fill="#8b949e" font-size="22" font-family="Arial">physical</text>
						<text x="760" y="175" fill="#8b949e" font-size="22" font-family="Arial">address</text>
					</svg>
				</section>
				<!-- Slide 1 -->
				<section data-background-color="#0d1117">
					<h1>The thing a programmer wants</h1>
					<h2 class="big">Read memory!</h2>
					<pre><code class="hljs asm" data-trim>
mov  eax, [ebx]        ; EBX = 0x00401000
  </code></pre>
					<p><strong>Question:</strong> What 32-bit address does the CPU actually put on the bus?</p>
				</section>

				<!-- Slide 2 -->
				<section>
					<h2>What we actually have right now</h2>
					<ul>
						<li>One <strong>16-bit</strong> number ‚Üí <code>DS</code> register (the selector)</li>
						<li>One <strong>32-bit</strong> number ‚Üí <code>EBX</code> (the offset)</li>
						<li class="fragment">We need to <strong>combine</strong> them to get a real address‚Ä¶</li>
					</ul>
				</section>

				<!-- Slide 3 -->
				<section>
					<h2>1980 way ‚Äì Real-mode 8086</h2>
					<pre><code class="hljs" data-trim>
DS = 0x1234 ‚Üí real base = 0x12340   (segment √ó 16)
Offset = only low 16 bits of EBX    (max 0xFFFF)
Physical address = 0x12340 + 0x5678 = 0x179B8
  </code></pre>
					<p class="fragment" style="color:#ff5555">Only ~1 MB, weird math, no memory protection</p>
				</section>

				<!-- Slide 4 -->
				<section>
					<h2>The dream</h2>
					<h3 class="big">A clean 32-bit flat address space</h3>
					<ul>
						<li>No √ó16 shifting</li>
						<li>No 64 KB segment limits</li>
						<li>Just 0x00000000 ‚Üí 0xFFFFFFFF</li>
					</ul>
					<p class="fragment big">We call this the <strong>linear address</strong></p>
				</section>

				<!-- Slide 5 -->
				<section>
					<h2>Logical address = the pair the programmer writes</h2>
					<pre><code class="hljs asm" data-trim>
mov eax, ds:[ebx]     ; logical address = DS : EBX
  </code></pre>
					<p>Example logical address: <code>0x0023 : 0x00401000</code></p>
					<p class="fragment">This is <strong>not</strong> the final address yet!</p>
				</section>

				<!-- Slide 6 -->
				<section>
					<h2>The huge problem</h2>
					<h3>Where is the 32-bit base address hiding?</h3>
					<p>The selector (<code>0x0023</code>) is only 16 bits ‚Üí it <strong>cannot</strong> hold a 32-bit
						base!</p>
					<p class="fragment big">So the real base must live somewhere else‚Ä¶</p>
				</section>

				<!-- Slide 7 -->
				<section>
					<h2>Meet the hero: the segment descriptor</h2>
					<p>An 8-byte structure that contains:</p>
					<ul>
						<li>Full <strong>32-bit base address</strong></li>
						<li>Segment limit (size)</li>
						<li>Permissions, type, flags</li>
					</ul>
				</section>

				<!-- Slide 8 -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">A Segment Descriptor</h2>

					<table
						style="margin:60px auto; font-size:34px; border-collapse:collapse; background:#000; color:white;">
						<tr style="background:#1565c0; color:white;">
							<th>Byte</th>
							<th>7</th>
							<th>6</th>
							<th>5</th>
							<th>4</th>
							<th>3</th>
							<th>2</th>
							<th>1</th>
							<th>0</th>
						</tr>

						<!-- Byte 7 -->
						<tr>
							<td style="background:#0d47a1; color:white;">7</td>
							<td colspan="8"
								style="background:#1e88e5; text-align:center; font-weight:bold; vertical-align: middle;">
								Base 31:24
							</td>
						</tr>

						<!-- Byte 6 -->
						<tr>
							<td style="background:#6d4c41; color:white;">6</td>
							<td colspan="4" style="background:#8d6e63; text-align:center;">Limit 19:16</td>
							<td style="background:#43a047;">AVL</td>
							<td style="background:#111; color:#666;">0</td>
							<td style="background:#43a047;">D/B</td>
							<td style="background:#43a047;">G</td>
						</tr>

						<!-- Byte 5 -->
						<tr>
							<td style="background:#6d4c41; color:white;">5</td>
							<td style="background:#7b1fa2;">P</td>
							<td colspan="2" style="background:#7b1fa2;">DPL</td>
							<td style="background:#7b1fa2;">S</td>
							<td colspan="4" style="background:#7b1fa2; text-align:center;">Type 3:0</td>
						</tr>

						<!-- Byte 4 -->
						<tr>
							<td style="background:#0d47a1; color:white;">4</td>
							<td colspan="8" rowspan="3"
								style="background:#1e88e5; text-align:center; font-weight:bold; vertical-align: middle;">
								Base 23:00
							</td>
						</tr>

						<!-- Byte 3 -->
						<tr>
							<td style="background:#0d47a1; color:white;">3</td>
						</tr>

						<!-- Byte 2 -->
						<tr>
							<td style="background:#0d47a1; color:white;">2</td>
						</tr>

						<!-- Byte 1 -->
						<tr>
							<td style="background:#8d6e63; color:white;">1</td>
							<td colspan="8" rowspan="2"
								style="background:#a1887f; text-align:center; font-weight:bold; vertical-align: middle;">
								Limit 15:0
							</td>
						</tr>

						<!-- Byte 0 -->
						<tr>
							<td style="background:#8d6e63; color:white;">0</td>
						</tr>
					</table>

					<div style="margin-top:50px; font-size:38px; color:#e0e0e0;">
						Blue = 32-bit Base‚ÄÉ Brown = 20-bit Limit‚ÄÉ Green = Flags‚ÄÉ Purple = Access rights
					</div>
				</section>

				<!-- Slide 9 -->
				<section>
					<h2>We need thousands of descriptors</h2>
					<p>Every program has many segments:</p>
					<ul>
						<li>code, data, stack, TLS, ‚Ä¶</li>
					</ul>
					<p class="fragment">‚Üí We need a <strong>big table</strong> of 8-byte descriptors</p>
				</section>

				<!-- Slide 10 -->
				<section data-background-color="#0d1117">
					<h3 style="color:#ff9800">Question: One giant table for the whole system?</h3>
					<p style="font-size:40px;">
						Or should every program get its own private table?
					</p>
					<div style="display:flex; justify-content:center; gap:120px; margin-top:80px;">
						<div style="text-align:center;">
							<h3 style="color:#42a5f5">One shared table</h3>
							<p style="font-size:38px;">‚Üí easy, fast<br>‚Üí kernel + all programs see the same
								descriptors
							</p>
						</div>
						<div style="text-align:center;">
							<h3 style="color:#ab47bc">One table per program</h3>
							<p style="font-size:38px;">‚Üí perfect isolation<br>‚Üí each program can have different
								bases/limits</p>
						</div>
					</div>
					<p class="fragment" style="margin-top:80px; font-size:50px; color:#ffcc80;">
						Intel gave us <strong>both</strong> ‚Üí GDT and LDT
					</p>
				</section>

				<section data-background-color="#0d1117">
					<h4 style="color:#ff9800">The Two Tables</h4>
					<div style="display:flex; justify-content:center; gap:100px; margin-top:60px;">
						<div style="background:#1e88e5; padding:30px; border-radius:16px; width:45%;">
							<h4 style="color:white;">Global Descriptor Table (GDT)
							</h4>
							<ul style="color:white; font-size:30px;">
								<li>Exactly <strong>one</strong> per system</li>
								<li>Shared by everyone</li>
								<li>Pointed to by <code>GDTR</code> register</li>
							</ul>
						</div>

						<div style="background:#7b1fa2; padding:30px; border-radius:16px; width:45%;">
							<h4 style="color:white;">Local Descriptor Table (LDT)</h4>
							<ul style="color:white; font-size:30px;">
								<li class="fragment">Zero or <strong>one per process</strong></li>
								<li>Private segments for that program</li>
								<li>Current LDT set with <code>lldt</code> instruction</li>
							</ul>
						</div>
					</div>

					<p style="margin-top:80px; font-size:46px; color:#ffcc80;">
						Most modern OSes use only GDT + flat model (base=0)<br>
						But the hardware still supports full per-process LDTs
					</p>
				</section>

				<!-- Slide 1 ‚Äì We have the table‚Ä¶ now what? -->
				<section data-background-color="#0d1117">
					<h3 style="color:#ff9800">We now have a huge table full of descriptors‚Ä¶</h3>
					<p style="font-size:65px; margin-top:140px; color:#ffcc80;">
						New problem:
					</p>
					<p style="font-size:50px; margin-top:80px; color:#ffcc80;">
						How does the CPU know <strong>which one</strong> of the descriptors to use<br>
						when the program does <code>mov eax, [ebx]</code> ?
					</p>
				</section>

				<!-- Slide 2 ‚Äì The segment register appears naturally -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">Finding the descriptor</h2>
					<p style="font-size:50px; margin-top:100px;">
						The instruction <code>mov eax, [ebx]</code> implicitly uses a segment register:
					</p>
					<pre style="font-size:40px; background:#111; padding:20px; margin-top:60px;">
    Default segment for [ebx] ‚Üí DS
  </pre>
					<p style="font-size:30px; margin-top:100px; color:#ffcc80;">
						So the CPU looks inside the <strong>DS register</strong> to find out<br>
						which descriptor it should load!
					</p>
				</section>

				<!-- Slide 3 ‚Äì What is really inside a segment register? -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">What is actually inside DS, CS, SS, etc.?</h2>
					<p style="font-size:60px; color:#ffcc80;">
						Two parts:
					</p>
					<div style="display:flex; justify-content:center; gap:100px; margin-top:80px; font-size:40px;">
						<div style="background:#1e88e5; padding:30px; border-radius:12px; color:white;">
							<strong>Visible part</strong><br>16-bit number<br>we load with mov, pop, etc.
						</div>
						<div style="background:#43a047; padding:30px; border-radius:12px; color:white;">
							<strong>Hidden part</strong><br>~96 bits<br>filled automatically by CPU<br>contains base,
							limit, flags
						</div>
					</div>
					<p style="font-size:30px; color:#ffcc80;">
						The visible 16-bit number is called the <strong>segment selector</strong>
					</p>
				</section>

				<!-- Slide 4 ‚Äì The selector is the key -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">So the selector is the key to the table</h2>
					<p style="font-size:70px; color:#ffcc80;">
						So what exactly is inside those 16 bits?
					</p>
				</section>

				<!-- Slide 5 ‚Äì First reveal: it must contain an index -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">The 16 bits must contain an index</h2>
					<p style="font-size:65px; margin-top:120px; color:#ffcc80;">
						We use 13 bits to pick one descriptor -> index
					</p>
					<p style="font-size:60px; margin-top:100px;">
						So most of the 16 bits are an <strong>index</strong> into the table
					</p>
				</section>

				<!-- Slide 6 ‚Äì Second reveal: we also need to choose GDT or LDT ‚Üí TI bit -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">We also need to choose the table (GDT or LDT)</h2>
					<p style="font-size:65px; margin-top:120px; color:#ffcc80;">
						‚Üí We need one more bit: the Table Indicator (TI)
					</p>
				</section>

				<!-- Slide 11 -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">The Selector Is Actually an Index!</h2>

					<table
						style="margin:80px auto; font-size:30px; border-collapse:collapse; background:#000; color:white;">
						<tr style="background:#1565c0; height:70px;">
							<th>15</th>
							<th>14</th>
							<th>13</th>
							<th>12</th>
							<th>11</th>
							<th>10</th>
							<th>9</th>
							<th>8</th>
							<th>7</th>
							<th>6</th>
							<th>5</th>
							<th>4</th>
							<th>3</th>
							<th>2</th>
							<th>1</th>
							<th>0</th>
						</tr>
						<tr style="height:120px; font-weight:bold;">
							<td colspan="13" style="background:#1e88e5; text-align:center; color:white;">
								Index (13 bits)
							</td>
							<td style="background:#43a047; color:white;">TI</td>
							<td colspan="2" style="background:#7b1fa2; text-align:center; color:white;">RPL</td>
						</tr>
					</table>

					<div style="margin-top:50px; font-size:42px; color:#ffcc80;">
						Example ‚Üí 0x0023 = Index = 4‚ÄÉ|‚ÄÉTI = 1 (LDT)‚ÄÉ|‚ÄÉRPL = 3 (user)
					</div>

					<div style="margin-top:40px; font-size:36px; color:#e0e0e0;">
						<span style="color:#42a5f5">Blue</span> = 13-bit Index ‚Üí which descriptor<br>
						<span style="color:#66bb6a">Green</span> = TI ‚Üí 0 = GDT, 1 = LDT<br>
						<span style="color:#ab47bc">Purple</span> = RPL ‚Üí privilege level (0‚Äì3)
					</div>
				</section>

				<!-- Slide 12 -->
				<section>
					<h2>How the CPU finds the descriptor</h2>
					<p>Descriptor address = <code>Table_base + (index √ó 8)</code></p>
					<p>Example: index 4 ‚Üí 4 √ó 8 = <strong>32 bytes</strong> into the table</p>
				</section>
				<section data-background-color="#0d1117">
					<svg width="1100" height="720" viewBox="0 0 1100 720" style="background:transparent;">

						<!-- Title -->
						<text x="550" y="60" font-size="32" fill="#ff9800" font-weight="bold" text-anchor="middle">
							Logical ‚Üí Linear Address Translation (Protected Mode)
						</text>

						<!-- SEGMENT SELECTOR -->
						<rect x="100" y="100" width="380" height="70" rx="12" fill="none" stroke="#fff"
							stroke-width="3" />
						<text x="290" y="140" font-size="26" fill="white" font-weight="bold"
							text-anchor="middle">SEGMENT
							SELECTOR</text>

						<!-- Selector fields -->
						<rect x="120" y="145" width="260" height="30" fill="#1e88e5" />
						<text x="250" y="167" font-size="20" fill="white" text-anchor="middle">INDEX (13 bits)</text>

						<!-- Bit numbers -->
						<text x="130" y="95" font-size="18" fill="#ccc">15</text>
						<text x="380" y="95" font-size="18" fill="#ccc">3</text>
						<text x="405" y="95" font-size="18" fill="#ccc">2</text>
						<text x="450" y="95" font-size="18" fill="#ccc">1 0</text>

						<!-- OFFSET -->
						<rect x="620" y="100" width="360" height="70" rx="12" fill="none" stroke="#fff"
							stroke-width="3" />
						<text x="800" y="140" font-size="26" fill="white" font-weight="bold"
							text-anchor="middle">OFFSET</text>
						<text x="630" y="95" font-size="18" fill="#ccc">31</text>
						<text x="970" y="95" font-size="18" fill="#ccc">0</text>

						<!-- Arrows down -->
						<path d="M290,170 L290,230" stroke="#fff" stroke-width="4" marker-end="url(#arrow)" />
						<path d="M800,170 Q800,300 740,340" stroke="#fff" stroke-width="4" marker-end="url(#arrow)" />

						<!-- Descriptor Table -->
						<rect x="180" y="250" width="320" height="200" rx="15" fill="none" stroke="#fff"
							stroke-width="3" />
						<text x="340" y="285" font-size="26" fill="white" font-weight="bold"
							text-anchor="middle">DESCRIPTOR
							TABLE</text>
						<text x="0" y="430" font-size="21" fill="#ffcc80">Segment descriptor‚Üí‚Üí‚Üí</text>

						<!-- Descriptor fields -->
						<rect x="200" y="310" width="280" height="35" fill="#7b1fa2" opacity="0.3" />
						<rect x="200" y="355" width="280" height="35" fill="#8d6e63" opacity="0.3" />
						<rect x="200" y="400" width="280" height="35" fill="#1e88e5" opacity="0.4" />

						<!-- Base address arrow -->
						<path d="M480,418 L580,418" stroke="#1e88e5" stroke-width="5" marker-end="url(#arrow)" />
						<text x="515" y="405" fill="#1e88e5" font-size="20">32-bit base</text>

						<!-- Adder -->
						<rect x="620" y="360" width="140" height="100" rx="15" fill="none" stroke="#fff"
							stroke-width="3" />
						<text x="690" y="410" font-size="28" fill="white" font-weight="bold"
							text-anchor="middle">ADDER</text>

						<!-- Final arrow down -->
						<path d="M690,460 L690,510" stroke="#ffcc80" stroke-width="6" marker-end="url(#arrow)" />

						<!-- Linear Address -->
						<rect x="520" y="530" width="360" height="70" rx="15" fill="none" stroke="#ffcc80"
							stroke-width="4" />
						<text x="700" y="575" font-size="32" fill="#ffcc80" font-weight="bold"
							text-anchor="middle">LINEAR
							ADDRESS</text>
						<text x="530" y="620" font-size="18" fill="#ccc">31</text>
						<text x="870" y="620" font-size="18" fill="#ccc">0</text>

						<!-- Arrow marker -->
						<defs>
							<marker id="arrow" markerWidth="12" markerHeight="12" refX="10" refY="6" orient="auto">
								<path d="M2,2 L10,6 L2,10" fill="none" stroke="currentColor" stroke-width="3" />
							</marker>
						</defs>
					</svg>
				</section>
				<!-- Slide 13 -->
				<section>
					<h2>Segment registers have a hidden part!</h2>
					<ul>
						<li>Visible: 16-bit selector</li>
						<li>Hidden (cached, ~96 bits):
							<ul>
								<li>32-bit base</li>
								<li>32-bit limit</li>
								<li>All flags (DPL, type, G, D/B, ‚Ä¶)</li>
							</ul>
						</li>
					</ul>
					<p class="fragment big">The CPU works almost entirely from the cache!</p>
				</section>


				<!-- Slide 14 -->
				<section>
					<h2>What really happens on <code>mov ds, ax</code></h2>
					<ol>
						<li>Take selector from AX</li>
						<li>Choose GDT or LDT (TI bit)</li>
						<li>Calculate descriptor address</li>
						<li>Read 8 bytes from memory</li>
						<li>Check permissions, present bit, etc.</li>
						<li><strong>Cache</strong> base/limit/flags in hidden part of DS</li>
					</ol>
				</section>

				<!-- Slide 15 -->
				<section>
					<h2>The magic moment ‚Äì calculating the linear address</h2>
					<p class="big">Linear address = <strong>cached 32-bit base</strong> + offset (EBX)</p>
					<p class="fragment">In <strong>99.9%</strong> of modern 32-bit OSes (Windows, Linux, etc.):</p>
				</section>

				<!-- Slide 16 -->
				<section>
					<h2>Full picture (without paging)</h2>
					<pre><code class="hljs" data-trim>
Logical address
   0x0023 : 0x00401000
        ‚Üì
Selector 0x0023 ‚Üí GDT/LDT ‚Üí descriptor ‚Üí base = 0x00000000
        ‚Üì
Linear address = 0x00000000 + 0x00401000 = 0x00401000
  </code></pre>
					<p class="fragment big">So <code>[ebx]</code> really does access 0x00401000!</p>
				</section>

				<!-- Slide 17 -->
				<section>
					<h2>Why all this insane complexity?</h2>
					<ul>
						<li>16-bit selector ‚Üí backward compatibility with 8086</li>
						<li>32-bit base ‚Üí full 4 GB addressing</li>
						<li>Descriptor ‚Üí memory protection & privileges</li>
						<li>Table + index ‚Üí sharing, relocation, fast revocation</li>
						<li>Hidden cache ‚Üí fast (no table lookup on every memory access)</li>
					</ul>
				</section>

				<!-- Slide 18 ‚Äì Final Summary -->
				<section data-background-color="#161b22">
					<h2>The entire story</h2>
					<ol style="font-size:42px; line-height:1.5">
						<li>Programmer writes <code>ds:[ebx]</code></li>
						<li>DS holds only a 16-bit selector</li>
						<li>Selector = index into GDT or LDT</li>
						<li>Descriptor (8 bytes) contains the real 32-bit base</li>
						<li>CPU caches base/limit/flags invisibly in DS</li>
						<li>Linear address = cached_base + ebx</li>
					</ol>
				</section>

				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">Practice #1 ‚Äì Decode selector 0x00CF</h2>
					<p style="font-size:50px; margin:80px 0;">Enter the values below:</p>

					<ul style="font-size:48px; line-height:1.8; color:#e0e0e0;">
						<li>Index (decimal): <input type="number" id="selector_prob1-index-dec" placeholder="e.g. 25"
								style="width:120px; font-size:44px; text-align:center;"></li>
						<li>TI bit: <input type="number" id="selector_prob1-ti" placeholder="0 or 1" min="0" max="1"
								style="width:80px; font-size:44px; text-align:center;"></li>
						<li>RPL (ring): <input type="number" id="selector_prob1-rpl" placeholder="0‚Äì3" min="0" max="3"
								style="width:80px; font-size:44px; text-align:center;"></li>
					</ul>

					<button onclick="checkSelector1()" style="font-size:40px; padding:10px 30px; margin-top:40px;">Check
						Answer</button>
					<p id="prob1-result" style="font-weight:bold; font-size:50px; margin-top:20px;"></p>

					<script>
						function checkSelector1() {
							const index = parseInt(document.getElementById('selector_prob1-index-dec').value);
							const ti = parseInt(document.getElementById('selector_prob1-ti').value);
							const rpl = parseInt(document.getElementById('selector_prob1-rpl').value);

							if (index === 25 && ti === 1 && rpl === 3) {
								document.getElementById('prob1-result').textContent = "Correct! Index=25, TI=1 (LDT), RPL=3";
								document.getElementById('prob1-result').style.color = "#4caf50";
							} else {
								document.getElementById('prob1-result').textContent = "Wrong ‚Äî try again!";
								document.getElementById('prob1-result').style.color = "#e91e63";
							}
						}
					</script>
				</section>

				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">Practice ‚Äì Maximum Descriptors in GDT & LDT</h2>

					<p style="font-size:40px; color:#e0e0e0;">
						Maximum number of descriptors each table can hold:
					</p>

					<ul style="font-size:35px; line-height:2.2; color:#e0e0e0; margin-left:100px;">
						<li>Global Descriptor Table (GDT) ‚Üí <input type="number" id="max-gdt" placeholder="?"
								style="width:180px; font-size:52px; text-align:center;"></li>
						<li>Local Descriptor Table (LDT) ‚Üí <input type="number" id="max-ldt" placeholder="?"
								style="width:180px; font-size:52px; text-align:center;"></li>
					</ul>

					<button onclick="checkGDTLDT()" style="font-size:46px; padding:14px 60px; margin-top:70px;">Check
						Answer</button>
					<p id="gdtldt-result" style="font-weight:bold; font-size:58px; margin-top:30px;"></p>

					<script>
						function checkGDTLDT() {
							const gdt = parseInt(document.getElementById('max-gdt').value);
							const ldt = parseInt(document.getElementById('max-ldt').value);

							if (gdt === 8192 && ldt === 8192) {
								document.getElementById('gdtldt-result').textContent = "Perfect! Both = 8192 (2¬π¬≥)";
								document.getElementById('gdtldt-result').style.color = "#4caf50";
							} else {
								document.getElementById('gdtldt-result').textContent = "Wrong ‚Üí Both GDT and LDT = 8192";
								document.getElementById('gdtldt-result').style.color = "#e91e63";
							}
						}
					</script>

					<aside class="notes">
						Correct answer: 8192 for both
						Reason: 13-bit index field in selector ‚Üí 2¬π¬≥ = 8192 entries
					</aside>
				</section>
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">Practice ‚Äì Maximum Size of a Descriptor Table</h2>

					<p style="font-size:58px; color:#e0e0e0;">
						What is the <strong>maximum possible size</strong> of a GDT or LDT in
						<strong>kilobytes</strong>?
					</p>

					<p style="font-size:60px; color:#e0e0e0;">
						Answer (in KB):
						<input type="number" id="max-size-kb" placeholder="?"
							style="width:180px; font-size:60px; text-align:center;">
					</p>

					<button onclick="checkGDTLDTMaxSize()"
						style="font-size:48px; padding:14px 70px; margin-top:80px;">Check
						Answer</button>
					<p id="size-result" style="font-weight:bold; font-size:60px; margin-top:30px;"></p>

					<script>
						function checkGDTLDTMaxSize() {
							const answer = parseInt(document.getElementById('max-size-kb').value);

							if (answer === 64) {
								document.getElementById('size-result').textContent = "Correct! 8192 √ó 8 bytes = 65,536 bytes = 64 KB";
								document.getElementById('size-result').style.color = "#4caf50";
							} else {
								document.getElementById('size-result').textContent = "Wrong ‚Üí 8192 √ó 8 = 65,536 bytes = 64 KB";
								document.getElementById('size-result').style.color = "#e91e63";
							}
						}
					</script>

					<aside class="notes">
						Correct answer: 64 KB
						Calculation: 8192 descriptors √ó 8 bytes = 65,536 bytes = 64 √ó 1024 = 64 KB
						The limit field in GDTR/LDTR is 16-bit ‚Üí max value 0xFFFF ‚Üí 65,535 bytes ‚Üí table size = 65,536
						bytes =
						exactly 64 KB
					</aside>
				</section>

				<!-- Slide 1 ‚Äì The Dream Everyone Wants -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">The Memory Model Everyone Actually Wants</h2>
					<p style="font-size:60px; color:#e0e0e0;">
						One giant, continuous address space<br>
						from <code>0x00000000</code> to <code>0xFFFFFFFF</code>
					</p>
					<p style="font-size:70px; color:#ffcc80;">
						No segments. No limits. No thinking.
					</p>
					<p class="fragment" style="font-size:65px; color:#4caf50;">
						This is called the <strong>Flat Memory Model</strong>
					</p>
				</section>

				<!-- Slide 2 ‚Äì How to make segmentation disappear -->
				<section data-background-color="#0d1117">
					<h3 style="color:#ff9800">How to Make Segmentation Invisible</h3>
					<p style="font-size:40px; color:#e0e0e0;">
						Just create segment descriptors like this:
					</p>

					<table
						style="margin:80px auto; font-size:30px; background:#111; color:white; border-collapse:collapse;">
						<tr style="background:#1565c0;">
							<th>Field</th>
							<th>Value</th>
							<th>Meaning</th>
						</tr>
						<tr>
							<td>Base</td>
							<td style="color:#42a5f5;">0x00000000</td>
							<td>Starts at address 0</td>
						</tr>
						<tr>
							<td>Limit</td>
							<td style="color:#8d6e63;">0xFFFFF</td>
							<td>20-bit = 1,048,575</td>
						</tr>
						<tr>
							<td>G (Granularity)</td>
							<td style="color:#43a047;">1</td>
							<td>Limit in 4 KB pages</td>
						</tr>
						<tr>
							<td style="background:#1b5e20; color:white;">Result ‚Üí</td>
							<td colspan="2" style="text-align:center;">4,294,967,295 bytes = <strong>4 GB</strong></td>
						</tr>
					</table>

					<p style="font-size:60px; margin-top:80px; color:#ffcc80;">
						‚Üí Linear address = offset (always!)
					</p>
				</section>

				<!-- Slide 4 ‚Äì Summary: Flat Model = Protected Mode Done Right -->
				<section data-background-color="#0d1117">
					<h2 style="color:#ff9800">Flat Model = Protected Mode Done Right</h2>

					<div style="font-size:40px; margin-top:80px; color:#e0e0e0; line-height:1.8;">
						<p>We <strong>must</strong> be in protected mode (for 32-bit addresses)</p>
						<p class="fragment">‚Üí So we use protected mode hardware‚Ä¶</p>
						<p class="fragment">‚Ä¶but make all segments cover the full 4 GB with base = 0</p>
					</div>

					<p style="font-size:50px; color:#4caf50;">
						<strong>Flat Model</strong> = Best of both worlds
					</p>
				</section>
			</section>

			<section>
				<section>
					<h3>Examples of registers in Pentium</h3>
					<ul>
						<li><strong>General Purpose Registers (GPRs):</strong>
							Can be freely used for arithmetic (<code>ADD</code>, <code>MUL</code>), logic, and data
							handling.</li>
						<li><strong>Special / Segment Registers:</strong>
							Reserved for memory segmentation ‚Äî you <em>cannot</em> use them for <code>ADD</code> or
							<code>MUL</code> because they store memory segment addresses, not data values.
						</li>
						<li><strong>Flag / Control Registers:</strong>
							Used internally by the CPU to track conditions (Zero, Carry, etc.) and control processor
							modes ‚Äî not accessible for normal arithmetic operations.</li>
					</ul>
				</section>
				<section>

					<h2><em>
							Registers are divided by purpose so the CPU can handle <strong>data processing, memory
								management,</strong> and <strong>control tasks</strong> efficiently and simultaneously.
						</em></h2>
				</section>

				<section>
					<h2>General Purpose Registers (GPRs)</h2>
					<p>Used for most CPU operations like arithmetic, logic, data movement, and memory addressing.
						Programmers can use these registers flexibly for temporary storage or calculations.</p>
				</section>



				<section>
					<h2>EAX ‚Äì Accumulator Register</h2>
					<p>Holds arithmetic and logic results. Automatically used in MUL, DIV, IN, OUT.</p>
					<pre><code>
MOV EAX, 5            ; Load 5 into EAX
ADD EAX, 10           ; Add 10 ‚Üí EAX = 15 (manual use)

MOV EBX, 4
MUL EBX               ; CPU automatically multiplies EAX √ó EBX
                      ; Result stored in EDX:EAX (low 32 bits in EAX)
  </code></pre>
				</section>
				<section>
					<h2>MUL Instruction Interactive Question</h2>
					<p>Consider the following 32-bit Pentium code:</p>
					<pre><code>
MOV EAX, 6       ; Load 6 into EAX
MOV EBX, 7       ; Load 7 into EBX
MUL EBX          ; Multiply EAX by EBX
  </code></pre>

					<p>After execution, enter the values in the boxes below:</p>
					<ul>
						<li>EAX: <input type="number" id="eax" placeholder="EAX value"></li>
						<li>EDX: <input type="number" id="edx" placeholder="EDX value"></li>
					</ul>

					<button onclick="checkEAXAnswer()">Check Answer</button>
					<p id="resulteax" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkEAXAnswer() {
							const eax = parseFloat(document.getElementById('eax').value);
							const edx = parseFloat(document.getElementById('edx').value);
							const correctEAX = 42.0;
							const correctEDX = 0.0;

							if (eax === correctEAX && edx === correctEDX) {
								document.getElementById('resulteax').textContent = "‚úÖ Correct! EAX = 42, EDX = 0";
								document.getElementById('resulteax').style.color = "green";
							} else {
								document.getElementById('resulteax').textContent = "‚ùå Incorrect. Try again!";
								document.getElementById('resulteax').style.color = "red";
							}
						}
					</script>
				</section>


				<section>
					<h2>EBX ‚Äì Base Register</h2>
					<p>Often used as a base for memory addressing.</p>
					<pre><code>
MOV EBX, OFFSET arr   ; EBX = base address of array 'arr'
MOV EAX, [EBX + 4]    ; Load 2nd element (base + offset 4 bytes)
  </code></pre>
				</section>

				<section>
					<h2>EBX Base Register Interactive Question</h2>
					<p>Consider the following 32-bit Pentium code:</p>
					<pre><code>
arr DWORD 10, 20, 30, 40 ; Array in memory

MOV EBX, OFFSET arr       ; Load base address of arr into EBX
MOV EAX, [EBX + 8]       ; Load 3rd element of the array into EAX
  </code></pre>

					<p>After execution, what value will be in <strong>EAX</strong>?</p>

					<input type="number" id="eax-ebx" placeholder="Enter EAX value">
					<button onclick="checkEBXAnswer()">Check Answer</button>

					<p id="result-ebx" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkEBXAnswer() {
							const eax = parseFloat(document.getElementById('eax-ebx').value, 10);
							const correctEAX = 30.0; // 3rd element in array (10,20,30,40)

							if (eax === correctEAX) {
								document.getElementById('result-ebx').textContent = "‚úÖ Correct! EAX = 30";
								document.getElementById('result-ebx').style.color = "green";
							} else {
								document.getElementById('result-ebx').textContent = "‚ùå Incorrect. Try again!";
								document.getElementById('result-ebx').style.color = "red";
							}
						}
					</script>
				</section>



				<section>
					<h2>ECX ‚Äì Counter Register</h2>
					<p>Used as loop/iteration counter. Automatically decremented by LOOP/REP instructions.</p>
					<pre><code>
MOV ECX, 3            ; Loop counter = 3
LoopStart:
  ADD EAX, 1          ; Add 1 to EAX
  LOOP LoopStart      ; Decrements ECX automatically, jumps if ECX ‚â† 0
</code></pre>
					<pre><code>
MOV ECX, 4
LEA ESI, [Source]
LEA EDI, [Dest]
REP MOVSB             
; MOVSB ‚Üí ‚ÄúMove String Byte‚Äù
; Copies 1 byte from memory at [ESI] ‚Üí [EDI]
; Copies bytes ECX times automatically
  </code></pre>
				</section>

				<section>
					<h3>ECX Register Interactive Question</h3>
					<p>Consider the following 32-bit Pentium code:</p>
					<pre><code>
MOV ECX, 5      ; Load 5 into ECX
MOV EAX, 0      ; Initialize EAX to 0

LoopStart:
ADD EAX, 2      ; Add 2 to EAX
LOOP LoopStart  ; Decrement ECX and loop until ECX = 0
  </code></pre>

					<p>After execution, what value will be in <strong>EAX</strong> and <strong>ECX</strong>?</p>

					<ul>
						<li>EAX: <input type="number" id="eax-ecx" placeholder="EAX value"></li>
						<li>ECX: <input type="number" id="ecx-ecx" placeholder="ECX value"></li>
					</ul>

					<button id="check-ecx-btn">Check Answer</button>
					<p id="result-ecx" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<script type="text/javascript">
					document.getElementById('check-ecx-btn').addEventListener('click', function () {
						const eax = parseFloat(document.getElementById('eax-ecx').value);
						const ecx = parseFloat(document.getElementById('ecx-ecx').value);

						const correctEAX = 10.0;  // 5 loops √ó 2 added each time
						const correctECX = 0.0;   // LOOP decrements ECX to 0

						if (eax === correctEAX && ecx === correctECX) {
							document.getElementById('result-ecx').textContent = "‚úÖ Correct! EAX = 10, ECX = 0";
							document.getElementById('result-ecx').style.color = "green";
						} else {
							document.getElementById('result-ecx').textContent = "‚ùå Incorrect. Try again!";
							document.getElementById('result-ecx').style.color = "red";
						}
					});
				</script>


				<section>
					<h2>EDX ‚Äì Data Register</h2>
					<p>Used in multiplication/division and I/O operations. Works automatically with EAX.</p>
					<pre><code>
MOV EAX, 10
MOV EBX, 3
MUL EBX               ; EAX √ó EBX ‚Üí Result in EDX:EAX

XOR EDX, EDX          ; Clear high bits
DIV EBX               ; Divide (EDX:EAX) / EBX ‚Üí Quotient in EAX, Remainder in EDX

MOV DX, 0x03F8
OUT DX, AL            ; Send AL to I/O port (DX)
  </code></pre>
				</section>

				<section>
					<h3>EDX/EAX Division Interactive Question</h3>
					<p>Consider the following 32-bit Pentium code:</p>
					<pre><code>
MOV EAX, 42      ; Dividend
MOV EBX, 7       ; Divisor
DIV EBX          ; Divide EAX by EBX
  </code></pre>

					<p>After execution, what value will be in <strong>EAX</strong> (Quotient) and <strong>EDX</strong>
						(Remainder)?</p>

					<ul>
						<li>EAX (Quotient): <input type="number" id="eax-div" placeholder="EAX value"></li>
						<li>EDX (Remainder): <input type="number" id="edx-div" placeholder="EDX value"></li>
					</ul>

					<button id="check-div-btn">Check Answer</button>
					<p id="result-div" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<script type="text/javascript">
					document.getElementById('check-div-btn').addEventListener('click', function () {
						const eax = parseFloat(document.getElementById('eax-div').value);
						const edx = parseFloat(document.getElementById('edx-div').value);

						const correctEAX = 6.0;   // Quotient
						const correctEDX = 0.0;   // Remainder

						if (eax === correctEAX && edx === correctEDX) {
							document.getElementById('result-div').textContent = "‚úÖ Correct! EAX = 6, EDX = 0";
							document.getElementById('result-div').style.color = "green";
						} else {
							document.getElementById('result-div').textContent = "‚ùå Incorrect. Try again!";
							document.getElementById('result-div').style.color = "red";
						}
					});
				</script>


				<section>
					<h2>ESI ‚Äì Source Index</h2>
					<p>Holds source memory address for string/memory operations.</p>
					<pre><code>
MOV ESI, OFFSET src   ; Load source address
MOV EDI, OFFSET dest  ; Load destination address
MOV ECX, 5            ; Number of bytes to copy
REP MOVSB             ; CPU automatically uses ESI as source
  </code></pre>
				</section>

				<section>
					<h2>EDI ‚Äì Destination Index</h2>
					<p>Holds destination memory address for string/memory operations.</p>
					<pre><code>
MOV ESI, OFFSET src   ; Source
MOV EDI, OFFSET dest  ; Destination
MOV ECX, 10
REP MOVSB             ; CPU automatically uses EDI as destination
  </code></pre>
				</section>

				<section>
					<h3>ESI/EDI Interactive Question</h3>
					<p style="font-size:0.80em;"><strong>Hint:</strong> Assume <code>arrSrc</code> starts at address
						<code>1000</code> and <code>arrDest</code> starts at address <code>2000</code>.
					</p>


					<div style="display:flex; justify-content:space-between; align-items:flex-start; gap: 30px;">

						<!-- Left side: Code -->
						<div style="flex:1; max-width:45%;">
							<pre style="max-height:250px; overflow-y:auto;"><code>
arrSrc DWORD 1, 2, 3, 4, 5
arrDest DWORD 0, 0, 0, 0, 0
MOV ESI, OFFSET arrSrc          ; ESI points to source array
MOV EDI, OFFSET arrDest         ; EDI points to destination array
MOV ECX, 3                      ; Number of DWORDs to copy
REP MOVSD                        ; Copies ECX DWORDs from [ESI] to [EDI]
      </code></pre>
						</div>

						<!-- Right side: Interactive inputs -->
						<div style="flex:1; max-width:45%;">
							<p>After execution, what will be the values of <strong>ESI</strong>, <strong>EDI</strong>,
								and <strong>ECX</strong>?</p>
							<ul>
								<li>ESI: <input type="number" id="esi-rep" placeholder="ESI value"></li>
								<li>EDI: <input type="number" id="edi-rep" placeholder="EDI value"></li>
								<li>ECX: <input type="number" id="ecx-rep" placeholder="ECX value"></li>
							</ul>
							<button id="check-rep-btn">Check Answer</button>

						</div>

					</div>
					<p id="result-rep" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<script type="text/javascript">
					document.getElementById('check-rep-btn').addEventListener('click', function () {
						const esi = parseFloat(document.getElementById('esi-rep').value);
						const edi = parseFloat(document.getElementById('edi-rep').value);
						const ecx = parseFloat(document.getElementById('ecx-rep').value);

						const baseESI = 1000;
						const baseEDI = 2000;

						const correctESI = baseESI + 12.0;  // 3 DWORDs √ó 4 bytes = 12
						const correctEDI = baseEDI + 12.0;  // 3 DWORDs √ó 4 bytes = 12
						const correctECX = 0.0;             // REP MOVSD decrements ECX to 0

						if (esi === correctESI && edi === correctEDI && ecx === correctECX) {
							document.getElementById('result-rep').textContent = `‚úÖ Correct! ESI = ${correctESI}, EDI = ${correctEDI}, ECX = 0`;
							document.getElementById('result-rep').style.color = "green";
						} else {
							document.getElementById('result-rep').textContent = "‚ùå Incorrect. Try again!";
							document.getElementById('result-rep').style.color = "red";
						}
					});
				</script>




				<section>
					<h2>EBP ‚Äì Base Pointer</h2>
					<p>Marks base of stack frame; used for accessing parameters and local variables.</p>
					<pre><code>
PUSH EBP              ; Save old base pointer
MOV  EBP, ESP         ; Set new base pointer
MOV  EAX, [EBP + 8]   ; Access function argument
MOV  EAX, [EBP - 4]   ; Access local variable
POP  EBP               ; Restore old base pointer
  </code></pre>
				</section>

				<section>
					<h2>ESP ‚Äì Stack Pointer</h2>
					<p>Points to top of the stack. Updated automatically by PUSH/POP.</p>
					<pre><code>
PUSH EAX              ; Push EAX ‚Üí ESP decreases by 4
POP  EBX              ; Pop into EBX ‚Üí ESP increases by 4
  </code></pre>
				</section>
				<!-- ================== ESP Slide ================== -->
				<section>
					<h3>ESP Register Interactive Question ‚Äì Stack Operations</h3>
					<p><small><strong>Hint:</strong> Assume ESP initially points to address <code>6000</code>.</small>
					</p>

					<div style="display:flex; justify-content:space-between; align-items:flex-start; gap:30px;">

						<!-- Left: Code -->
						<div style="flex:1; max-width:45%;">
							<pre style="max-height:220px; overflow-y:auto;"><code>
; Stack operations example
PUSH 10       ; ESP = ESP - 4, store 10 at [ESP]
PUSH 20       ; ESP = ESP - 4, store 20 at [ESP]
POP EAX       ; Load top value (20) into EAX, ESP = ESP + 4
      </code></pre>
						</div>

						<!-- Right: Inputs -->
						<div style="flex:1; max-width:45%;">
							<p>After execution, what will be the values of <strong>ESP</strong> and
								<strong>EAX</strong>?
							</p>
							<ul>
								<li>ESP: <input type="number" id="esp-slide1" placeholder="ESP value"></li>
								<li>EAX: <input type="number" id="eax-slide1" placeholder="EAX value"></li>
							</ul>
							<button id="check-esp-slide1">Check Answer</button>

						</div>

					</div>
					<p id="result-esp-slide1" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<script type="text/javascript">
					document.getElementById('check-esp-slide1').addEventListener('click', function () {
						const esp = parseFloat(document.getElementById('esp-slide1').value);
						const eax = parseFloat(document.getElementById('eax-slide1').value);

						const initialESP = 6000;
						const correctESP = 5996;  // PUSH 10 ‚Üí 5996, PUSH 20 ‚Üí 5992, POP ‚Üí 5996
						const correctEAX = 20;    // Last popped value

						if (esp === correctESP && eax === correctEAX) {
							document.getElementById('result-esp-slide1').textContent = `‚úÖ Correct! ESP = ${correctESP}, EAX = ${correctEAX}`;
							document.getElementById('result-esp-slide1').style.color = "green";
						} else {
							document.getElementById('result-esp-slide1').textContent = "‚ùå Incorrect. Try again!";
							document.getElementById('result-esp-slide1').style.color = "red";
						}
					});
				</script>

				<section>
					<h3>EBP Register Interactive Question ‚Äì Function Stack</h3>
					<p><small><strong>Hint:</strong> Assume the current ESP is at address <code>4000</code>.</small></p>

					<div style="display:flex; justify-content:space-between; align-items:flex-start; gap:30px;">

						<!-- Left: Code -->
						<div style="flex:1; max-width:45%;">
							<pre style="max-height:220px; overflow-y:auto;"><code>
PUSH EBP            ; Save old base pointer
MOV EBP, ESP        ; Set EBP to current stack pointer
SUB ESP, 16         ; Allocate 16 bytes for local variables
      </code></pre>
						</div>

						<!-- Right: Inputs -->
						<div style="flex:1; max-width:45%;">
							<p>After execution, what will be the values of <strong>EBP</strong> and
								<strong>ESP</strong>?
							</p>
							<ul>
								<li>EBP: <input type="number" id="ebp-slide2" placeholder="EBP value"></li>
								<li>ESP: <input type="number" id="esp-slide2" placeholder="ESP value"></li>
							</ul>
							<button id="check-ebp-slide2">Check Answer</button>

						</div>

					</div>
					<p id="result-ebp-slide2" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<script type="text/javascript">
					document.getElementById('check-ebp-slide2').addEventListener('click', function () {
						const ebp = parseFloat(document.getElementById('ebp-slide2').value);
						const esp = parseFloat(document.getElementById('esp-slide2').value);

						const initialESP = 4000;       // Stack starts at 4000
						const correctEBP = initialESP - 4; // MOV EBP, ESP ‚Üí EBP = 4000
						const correctESP = correctEBP - 16; // Allocate 16 bytes ‚Üí ESP = 3984

						if (ebp === correctEBP && esp === correctESP) {
							document.getElementById('result-ebp-slide2').textContent = `‚úÖ Correct! EBP = ${correctEBP}, ESP = ${correctESP}`;
							document.getElementById('result-ebp-slide2').style.color = "green";
						} else {
							document.getElementById('result-ebp-slide2').textContent = "‚ùå Incorrect. Try again!";
							document.getElementById('result-ebp-slide2').style.color = "red";
						}
					});
				</script>



				<section>
					<h2>Special Purpose / Segment Registers</h2>
					<p>Dedicated to memory segmentation. Each register points to a specific memory segment (code, data,
						stack, or extra). They are not used for arithmetic or general calculations.</p>
					<ul>
						<li>CS ‚Äì Code Segment: points to instructions</li>
						<li>DS ‚Äì Data Segment: points to variables</li>
						<li>SS ‚Äì Stack Segment: points to stack</li>
						<li>ES / FS / GS ‚Äì Extra segments for additional memory access</li>
					</ul>
				</section>



				<section>
					<h3>DS Register ‚Äì Data Segment (Pentium 32-bit Flat Model)</h3>
					<p><small><strong>Hint:</strong> <code>.data</code> section starts at <code>0x00401000</code>. DS
							selector base = <code>0</code> (flat model).</small></p>

					<div class="flex">
						<div class="col">
							<pre><code>DATA1  DWORD 10      <span class="code-comment">; at 0x00401000</span>
DATA2  DWORD 20      <span class="code-comment">; at 0x00401004</span>

MOV AX, [DATA2]     <span class="code-comment">; loads from linear address of DATA2</span>
</code></pre>
						</div>

						<div class="col">
							<p>What **linear address** (hex, full 8 digits) is read to load AX?</p>
							<input type="text" id="addr-ds" placeholder="e.g. 00401004"
								style="width:140px; text-transform:uppercase;">
							<button id="check-ds">Check</button>
							<p id="result-ds" class="result"></p>
						</div>
					</div>
				</section>

				<script>
					document.getElementById('check-ds').onclick = function () {
						const ans = document.getElementById('addr-ds').value.trim().toUpperCase();
						const correct = '00401004';
						document.getElementById('result-ds').style.color = (ans === correct) ? 'green' : 'red';
						document.getElementById('result-ds').textContent =
							(ans === correct) ? '‚úÖ Correct! [DATA2] = 00401004h (DATA1 takes 4 bytes)' : '‚ùå Incorrect. .data + 4 = 00401004h';
					};
				</script>


				<!-- ============================================================= -->
				<!-- 2. CS ‚Äì Code Segment (32-bit Flat Model)                     -->
				<!-- ============================================================= -->
				<section>
					<h3>CS Register ‚Äì Code Segment (Pentium 32-bit Flat Model)</h3>
					<p><small><strong>Hint:</strong> <code>.code</code> section starts at <code>0x00400000</code>. CS
							selector base = <code>0</code>.</small></p>

					<div class="flex">
						<div class="col">
							<pre><code>START:
    MOV  AX, 5
    ADD  AX, 10
    JMP  START          <span class="code-comment">; jumps to linear address of START</span>
</code></pre>
						</div>

						<div class="col">
							<p>The <code>JMP START</code> fetches its target from which **linear address** (hex)?</p>
							<input type="text" id="addr-cs" placeholder="e.g. 00400000"
								style="width:140px; text-transform:uppercase;">
							<button id="check-cs">Check</button>
							<p id="result-cs" class="result"></p>
						</div>
					</div>
				</section>

				<script>
					document.getElementById('check-cs').onclick = function () {
						const ans = document.getElementById('addr-cs').value.trim().toUpperCase();
						const correct = '00400000';
						document.getElementById('result-cs').style.color = (ans === correct) ? 'green' : 'red';
						document.getElementById('result-cs').textContent =
							(ans === correct) ? '‚úÖ Correct! START = 00400000h (start of .code)' : '‚ùå Incorrect. CS base=0 + offset of START';
					};
				</script>


				<!-- ============================================================= -->
				<!-- 3. SS ‚Äì Stack Segment (32-bit Flat Model)                    -->
				<!-- ============================================================= -->
				<section>
					<h3>SS Register ‚Äì Stack Segment (Pentium 32-bit Flat Model)</h3>
					<p><small><strong>Hint:</strong> SS selector base = <code>0</code>. Stack grows downward from
							<code>0x00403000</code>. ESP = <code>0x00402FFC</code> **before** PUSH.</small></p>

					<div class="flex">
						<div class="col">
							<pre><code>PUSH 50      <span class="code-comment">; push DWORD (4 bytes)</span>
POP  EBX     <span class="code-comment">; pop DWORD into EBX</span>
</code></pre>
						</div>

						<div class="col">
							<p>At which **linear address** (hex) is the value `50` **stored** by PUSH?</p>
							<input type="text" id="addr-ss" placeholder="e.g. 00402FF8"
								style="width:140px; text-transform:uppercase;">
							<button id="check-ss">Check</button>
							<p id="result-ss" class="result"></p>
						</div>
					</div>
				</section>

				<script>
					document.getElementById('check-ss').onclick = function () {
						const ans = document.getElementById('addr-ss').value.trim().toUpperCase();
						const correct = '00402FF8';
						document.getElementById('result-ss').style.color = (ans === correct) ? 'green' : 'red';
						document.getElementById('result-ss').textContent =
							(ans === correct) ? '‚úÖ Correct! PUSH: ESP -= 4 ‚Üí 00402FF8h' : '‚ùå Incorrect. Stack grows down by 4 bytes (DWORD)';
					};
				</script>


				<!-- ============================================================= -->
				<!-- 4. ES ‚Äì Extra Segment (String Copy)                          -->
				<!-- ============================================================= -->
				<section>
					<h3>ES Register ‚Äì String Operations (Pentium 32-bit Flat Model)</h3>
					<p><small><strong>Hint:</strong> ES selector base = <code>0</code>. <code>arrDest</code> starts at
							<code>0x00402000</code>.</small></p>

					<div class="flex">
						<div class="col">
							<pre><code>arrSrc  DWORD 1,2,3         <span class="code-comment">; e.g. 0x00401000</span>
arrDest DWORD 0,0,0         <span class="code-comment">; 0x00402000, +4, +8</span>

MOV ESI, OFFSET arrSrc      <span class="code-comment">; ESI = 0x00401000</span>
MOV EDI, OFFSET arrDest     <span class="code-comment">; EDI = 0x00402000</span>
MOV ECX, 2
REP MOVSD                   <span class="code-comment">; copy 2 DWORDs to ES:[EDI]</span>
</code></pre>
						</div>

						<div class="col">
							<p>After <code>REP MOVSD</code> finishes, what **linear address** (hex) is in
								<strong>EDI</strong>?
							</p>
							<input type="text" id="addr-es" placeholder="e.g. 00402008"
								style="width:140px; text-transform:uppercase;">
							<button id="check-es">Check</button>
							<p id="result-es" class="result"></p>
						</div>
					</div>
				</section>

				<script>
					document.getElementById('check-es').onclick = function () {
						const ans = document.getElementById('addr-es').value.trim().toUpperCase();
						const correct = '00402008';
						document.getElementById('result-es').style.color = (ans === correct) ? 'green' : 'red';
						document.getElementById('result-es').textContent =
							(ans === correct) ? '‚úÖ Correct! EDI += 2√ó4 = 00402008h' : '‚ùå Incorrect. MOVSD advances EDI by 4 per DWORD';
					};
				</script>




				<section>
					<h2>Flag / Control Registers</h2>
					<p>Used by the CPU or OS to manage system state, control operations, and track results. These
						registers are <b>hardware-focused</b>.</p>
					<ul>
						<li>EFLAGS ‚Äì status flags (Zero, Carry, Sign, Overflow) and control flags</li>
						<li>CR0 ‚Äì CR4 ‚Äì control registers for enabling protected mode, paging, and CPU features</li>
					</ul>
				</section>

			</section>

			<section>
				<!-- Introduction to Assembly Language Statements -->
				<section>
					<h2>Introduction to Assembly Language Statements</h2>
					<ul>
						<li><strong>Executable Instructions:</strong> Tell the processor what to do; generate machine
							code.</li>
						<li><strong>Assembler Directives (Pseudo-ops):</strong> Provide info to assembler; do not
							generate machine code.</li>
						<li><strong>Macros:</strong> Shorthand for a group of statements; replaced by their statements
							during assembly.</li>
					</ul>
					<p><strong>Format:</strong></p>
					<p><code>[label] mnemonic [operands] [;comment]</code></p>
				</section>

				<section>
					<h3>Executable Instruction</h3>
					<pre><code>repeat:
    INC result  ; increment result by 1</code></pre>

					<h3>Directive</h3>
					<pre><code>CR EQU 0DH  ; define carriage-return constant</code></pre>

					<h3>Macro</h3>
					<pre><code>PRINT_MSG MACRO
    MOV DX, offset msg
    MOV AH, 09H
    INT 21H
ENDM</code></pre>
				</section>

				<!-- Quiz: Identify Statement Type -->
				<section>
					<h3>Interactive Quiz: Identify Statement Type</h3>
					<pre><code>
1)  MOV BX, AX
2)  MAX_VALUE EQU 100
3)  SUM_MACRO MACRO
  </code></pre>
					<p>Choose the type for each (Executable / Directive / Macro):</p>
					<ul>
						<li>1Ô∏è‚É£:
							<select id="stmt-type-1">
								<option value="">Select type</option>
								<option value="executable">Executable</option>
								<option value="directive">Directive</option>
								<option value="macro">Macro</option>
							</select>
						</li>
						<li>2Ô∏è‚É£:
							<select id="stmt-type-2">
								<option value="">Select type</option>
								<option value="executable">Executable</option>
								<option value="directive">Directive</option>
								<option value="macro">Macro</option>
							</select>
						</li>
						<li>3Ô∏è‚É£:
							<select id="stmt-type-3">
								<option value="">Select type</option>
								<option value="executable">Executable</option>
								<option value="directive">Directive</option>
								<option value="macro">Macro</option>
							</select>
						</li>
					</ul>
					<button id="check-stmt-types">Check Answers</button>
					<p id="result-stmt-types" style="margin-top:10px; font-weight:bold;"></p>
				</section>

				<section>
					<h2>Practice ‚Äì Label and Mnemonic Identification</h2>
					<p>Identify the <strong>label</strong>, <strong>mnemonic</strong>, and <strong>operand</strong> in
						each statement:</p>
					<ul>
						<li>1. <code>start: MOV AX, 5</code></li>
						<li>2. <code>LOOP: ADD AX, BX</code></li>
						<li>3. <code>END_MACRO MACRO ... ENDM</code></li>
					</ul>
					<p><em>Hint:</em> Labels usually precede a colon, mnemonic is the operation, operand is the target
						or source.</p>
				</section>

				<section>
					<h2>True or False ‚Äì Assembly Statements</h2>
					<ul>
						<li>Executable instructions generate machine code. Correct</li>
						<li>Directives are executed by the CPU. Incorrect</li>
						<li>Macros can replace multiple instructions with one name. Correct</li>
					</ul>
				</section>
			</section>

			<!-- Data Allocation Section -->
			<section>
				<section>
					<h2>Data Allocation in High-Level Languages</h2>
					<p>In languages like C, storage for variables is allocated by specifying <strong>data
							types</strong>.</p>
				</section>
				<section>
					<h2>C Variable Declarations</h2>
					<pre><code>char response;  /* 1 byte */
int value;       /* 4 bytes */
float total;     /* 4 bytes */
double temp;     /* 8 bytes */</code></pre>
				</section>
				<section>
					<h2>Bit Pattern Interpretation</h2>
					<p>Two variables with same storage size may represent different values:</p>
					<pre><code>unsigned value_1;
int value_2;</code></pre>
				</section>
				<section>
					<p>Bit pattern: <code>8FF08DB9H</code></p>
					<ul>
						<li>Stored in <code>value_1</code> ‚Üí +2.4149√ó10‚Åπ</li>
						<li>Stored in <code>value_2</code> ‚Üí ‚àí1.88006√ó10‚Åπ</li>
					</ul>
				</section>
				<section>
					<h2>Data Allocation in Assembly</h2>
					<p>Use <strong>define directives</strong> to reserve and initialize memory.</p>
					<p>No automatic interpretation is attached to the data.</p>
				</section>
				<section>
					<h2>Format of Storage Allocation</h2>
					<pre><code>[variable-name] define-directive initial-value [, initial-value], ...</code></pre>
					<p>No colon follows the variable name.</p>
				</section>

				<section>
					<h2>Define Directives</h2>
					<ul>
						<li><code>DB</code> ‚Äì Define Byte (1 byte)</li>
						<li><code>DW</code> ‚Äì Define Word (2 bytes)</li>
						<li><code>DD</code> ‚Äì Define Doubleword (4 bytes)</li>
						<li><code>DQ</code> ‚Äì Define Quadword (8 bytes)</li>
						<li><code>DT</code> ‚Äì Define Ten Bytes (10 bytes)</li>
					</ul>
				</section>

				<section>
					<h2>Byte Example</h2>
					<pre><code>sorted DB 'y'      ; stores character y
sorted DB 79H       ; stores same as 'y'
sorted DB 1111001B  ; binary equivalent</code></pre>
				</section>
				<section>
					<h2>Word Example</h2>
					<pre><code>value DW 25159</code></pre>
					<p>16-bit (little-endian): <code>47 62</code></p>
				</section>
				<section>
					<h2>Negative Word Example</h2>
					<pre><code>balance DW -29255</code></pre>
					<p>2's complement: <code>B9 8D</code></p>
				</section>
				<section>
					<h2>Doubleword Example</h2>
					<pre><code>total DD 542803535</code></pre>
					<p>Stored: <code>4F 86 5A 20</code></p>
				</section>

				<!-- Quiz 1: Directive Size -->
				<section>
					<h2>Quiz 1: Identify Directive Type</h2>
					<p>Select the correct define directive:</p>
					<ul>
						<li>1Ô∏è‚É£ 1 byte for a character: <select id="dir-char">
								<option value="">Select</option>
								<option value="db">DB</option>
								<option value="dw">DW</option>
								<option value="dd">DD</option>
							</select></li>
						<li>2Ô∏è‚É£ 4 bytes for an integer: <select id="dir-int">
								<option value="">Select</option>
								<option value="db">DB</option>
								<option value="dw">DW</option>
								<option value="dd">DD</option>
							</select></li>
						<li>3Ô∏è‚É£ 2 bytes for a small number: <select id="dir-word">
								<option value="">Select</option>
								<option value="db">DB</option>
								<option value="dw">DW</option>
								<option value="dd">DD</option>
							</select></li>
					</ul>
					<button id="check-dir-sizes">Check</button>
					<p id="result-dir-sizes" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<!-- Quiz 2: Little-Endian Storage -->
				<section>
					<h2>Quiz 2: Little-Endian Storage</h2>
					<p>How is <code>25159</code> (16-bit) stored in memory?</p>
					<input type="text" id="little-endian-input" placeholder="e.g. 47 62"
						style="font-family: monospace; width: 120px;">
					<button id="check-little-endian">Check</button>
					<p id="result-little-endian" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<!-- Quiz 3: Negative Number (2's Complement) -->
				<section>
					<h2>Quiz 3: Negative Number Storage</h2>
					<p><code>-29255</code> as 16-bit 2's complement (little-endian):</p>
					<input type="text" id="neg-2s-input" placeholder="e.g. B9 8D"
						style="font-family: monospace; width: 120px; text-transform: uppercase;">
					<button id="check-neg-2s">Check</button>
					<p id="result-neg-2s" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<section>
					<h1>Data Allocation in Assembly</h1>
					<p>DB ‚Ä¢ DW ‚Ä¢ DD ‚Ä¢ DQ ‚Ä¢ RESB ‚Ä¢ TIMES ‚Ä¢ Symbol Table</p>
				</section>

				<section>
					<h2>Numeric Operand Ranges</h2>
					<table border="1" style="font-size:24px; margin: auto;">
						<tr>
							<th>Directive</th>
							<th>Range</th>
						</tr>
						<tr>
							<td>DB</td>
							<td>-128 to 255</td>
						</tr>
						<tr>
							<td>DW</td>
							<td>-32768 to 65535</td>
						</tr>
						<tr>
							<td>DD</td>
							<td>-2,147,483,648 to 4,294,967,295<br>or 32-bit float</td>
						</tr>
						<tr>
							<td>DQ</td>
							<td>-2‚Å∂¬≥ to 2‚Å∂‚Å¥-1<br>or 64-bit float</td>
						</tr>
					</table>
				</section>

				<section>
					<h2>Examples: Real Numbers</h2>
					<pre>
float1 DD 1.234
real2  DQ 123.456
  </pre>
					<p>DD ‚Üí 32-bit float<br>DQ ‚Üí 64-bit float</p>
				</section>

				<!-- Quiz 4: Floating Point & Range -->
				<section>
					<h2>Quiz 4: Choose Correct Directive</h2>
					<p>1Ô∏è‚É£ 64-bit float: <select id="fp64">
							<option value="">Select</option>
							<option value="dq">DQ</option>
							<option value="dd">DD</option>
						</select></p>
					<p>2Ô∏è‚É£ Range ‚àí128 to 255: <select id="range-byte">
							<option value="">Select</option>
							<option value="db">DB</option>
							<option value="dw">DW</option>
						</select></p>
					<button id="check-fp-range">Check</button>
					<p id="result-fp-range" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<section>
					<h2>Uninitialized Data</h2>
					<ul>
						<li>RESB ‚Äî Reserve Byte</li>
						<li>RESW ‚Äî Reserve Word</li>
						<li>RESD ‚Äî Reserve Doubleword</li>
						<li>RESQ ‚Äî Reserve Quadword</li>
						<li>REST ‚Äî Reserve Ten Bytes</li>
					</ul>
					<pre>
response RESB 1
buffer   RESW 100
total    RESD 1
  </pre>
				</section>

				<!-- Quiz 5: Reserve Directives -->
				<section>
					<h2>Quiz 5: Reserve Directives</h2>
					<p>1Ô∏è‚É£ Reserve 10 words: <select id="res-words">
							<option value="">Select</option>
							<option value="resw">RESW</option>
							<option value="resb">RESB</option>
						</select></p>
					<p>2Ô∏è‚É£ Reserve a doubleword: <select id="res-dword">
							<option value="">Select</option>
							<option value="resd">RESD</option>
							<option value="resq">RESQ</option>
						</select></p>
					<button id="check-reserve">Check</button>
					<p id="result-reserve" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<section>
					<h2>Multiple Definitions</h2>
					<pre>
sort  DB 'y'
value DW 25159
total DD 542803535
  </pre>
					<p>Stored in <b>contiguous memory</b>.</p>
				</section>

				<section>
					<h2>Memory Layout Example</h2>
					<pre>
address: x   x+1 x+2 x+3 x+4 x+5 x+6
contents: 79          ; 'y'
          47 62       ; 25159 ‚Üí 6247h
          4F 86 5A 20 ; DD
  </pre>
				</section>

				<!-- Quiz 6: TIMES Directive -->
				<section>
					<h2>Quiz 6: TIMES Directive</h2>
					<p>Create array of 5 bytes initialized to 0:</p>
					<select id="times-array">
						<option value="">Select</option>
						<option value="times">TIMES 5 DB 0</option>
						<option value="resb">RESB 5</option>
						<option value="wrong">DB 5 TIMES 0</option>
					</select>
					<button id="check-times">Check</button>
					<p id="result-times" style="font-weight:bold; margin-top:10px;"></p>
				</section>

				<section>
					<h2>Symbol Table</h2>
					<p>The <strong>assembler</strong> automatically tracks every <em>variable</em> and <em>label</em>
						you define.</p>
					<p>It stores their <strong>memory offset</strong> (in bytes) from the start of the data/code
						section.</p>
					<p style="font-size: 0.8em; margin-top: 20px;">Think of it as a <strong>phonebook</strong> for your
						program‚Äôs names.</p>
				</section>

				<section>
					<h2>Symbol Table Example</h2>
					<pre><code class="hljs" style="font-size: 0.9em;">
value   DW 0      ; 2 bytes
sum     DD 0      ; 4 bytes
flag    DB 1      ; 1 byte
  </code></pre>
					<table style="margin-top: 20px; font-size: 0.9em;">
						<tr>
							<th>Symbol</th>
							<th>Offset</th>
						</tr>
						<tr>
							<td>value</td>
							<td>0</td>
						</tr>
						<tr>
							<td>sum</td>
							<td>2</td>
						</tr>
						<tr>
							<td>flag</td>
							<td>6</td>
						</tr>
					</table>
					<p style="margin-top: 15px; font-size: 0.8em;"><strong>Why?</strong> 0 ‚Üí 2 ‚Üí 6 (2 + 4 = 6)</p>
				</section>

				<section>
					<h2>Symbol Table</h2>
					<pre>
value  DW 0
sum    DD 0
marks  TIMES 10 DW 0
message DB 'The grade is:',0
char1   DB ?
  </pre>
					<p>Offsets assigned in bytes.</p>
				</section>

				<section>
					<h2>Symbol Table Output</h2>
					<pre>
value   ‚Üí offset 0
sum     ‚Üí offset 2
marks   ‚Üí offset 6
message ‚Üí offset 26
char1   ‚Üí offset 40
  </pre>
				</section>

				<!-- Quiz 7: Symbol Table Offset -->
				<section>
					<h2>Quiz 7: Symbol Table Offset</h2>
					<p>Given: <code>a DW 0</code>, <code>b DD 0</code>, <code>c DB 0</code> ‚Üí offset of <code>c</code>?
					</p>
					<input type="number" id="offset-c" placeholder="e.g. 6" style="width: 80px;">
					<button id="check-offset">Check</button>
					<p id="result-offset" style="font-weight:bold; margin-top:10px;"></p>
				</section>
			</section>

			<!-- Master JavaScript (All Quizzes) -->
			<script>
				document.addEventListener('DOMContentLoaded', function () {
					// Quiz: Statement Types
					document.getElementById('check-stmt-types')?.addEventListener('click', () => {
						const s1 = document.getElementById('stmt-type-1').value;
						const s2 = document.getElementById('stmt-type-2').value;
						const s3 = document.getElementById('stmt-type-3').value;
						const r = document.getElementById('result-stmt-types');
						if (s1 === 'executable' && s2 === 'directive' && s3 === 'macro') {
							r.textContent = 'Correct! Well identified.'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect. Try again.'; r.style.color = 'red';
						}
					});

					// Quiz 1: Directive Sizes
					document.getElementById('check-dir-sizes')?.addEventListener('click', () => {
						const d1 = document.getElementById('dir-char').value;
						const d2 = document.getElementById('dir-int').value;
						const d3 = document.getElementById('dir-word').value;
						const r = document.getElementById('result-dir-sizes');
						if (d1 === 'db' && d2 === 'dd' && d3 === 'dw') {
							r.textContent = 'Correct!'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect. DB=1, DW=2, DD=4 bytes.'; r.style.color = 'red';
						}
					});

					// Quiz 2: Little-Endian
					document.getElementById('check-little-endian')?.addEventListener('click', () => {
						const input = document.getElementById('little-endian-input').value.trim().toUpperCase();
						const r = document.getElementById('result-little-endian');
						if (input === '47 62') {
							r.textContent = 'Correct! LSB first.'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect. Try 47 62'; r.style.color = 'red';
						}
					});

					// Quiz 3: Negative 2's Complement
					document.getElementById('check-neg-2s')?.addEventListener('click', () => {
						const input = document.getElementById('neg-2s-input').value.trim().toUpperCase();
						const r = document.getElementById('result-neg-2s');
						if (input === 'B9 8D') {
							r.textContent = 'Correct! 2\'s complement.'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect. Try B9 8D'; r.style.color = 'red';
						}
					});

					// Quiz 4: FP & Range
					document.getElementById('check-fp-range')?.addEventListener('click', () => {
						const fp = document.getElementById('fp64').value;
						const range = document.getElementById('range-byte').value;
						const r = document.getElementById('result-fp-range');
						if (fp === 'dq' && range === 'db') {
							r.textContent = 'Correct!'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect.'; r.style.color = 'red';
						}
					});

					// Quiz 5: Reserve
					document.getElementById('check-reserve')?.addEventListener('click', () => {
						const w = document.getElementById('res-words').value;
						const d = document.getElementById('res-dword').value;
						const r = document.getElementById('result-reserve');
						if (w === 'resw' && d === 'resd') {
							r.textContent = 'Correct!'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect.'; r.style.color = 'red';
						}
					});

					// Quiz 6: TIMES
					document.getElementById('check-times')?.addEventListener('click', () => {
						const val = document.getElementById('times-array').value;
						const r = document.getElementById('result-times');
						if (val === 'times') {
							r.textContent = 'Correct!'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect. Use TIMES 5 DB 0'; r.style.color = 'red';
						}
					});

					// Quiz 7: Offset
					document.getElementById('check-offset')?.addEventListener('click', () => {
						const val = document.getElementById('offset-c').value;
						const r = document.getElementById('result-offset');
						if (val === '6') {
							r.textContent = 'Correct! DW=2, DD=4 ‚Üí 2+4=6'; r.style.color = 'green';
						} else {
							r.textContent = 'Incorrect. 2 + 4 = 6'; r.style.color = 'red';
						}
					});
				});
			</script>

			<section>
				<!-- ==================== WHERE ARE THE OPERANDS? ==================== -->
				<section>
					<h2>Where Are the Operands?</h2>
					<p>Every instruction needs <strong>data</strong> to work on.</p>
					<p style="margin-top: 20px; font-size: 0.9em;">Question: <em>Where is the data?</em></p>
					<p style="color: #4CAF50; font-weight: bold;">Answer: In 4 possible places!</p>
				</section>

				<!-- Slide: 4 Places -->
				<section>
					<h2>4 Places for Operands</h2>
					<ol style="font-size: 0.9em;">
						<li>In a <strong>register</strong> (CPU)</li>
						<li>In the <strong>instruction itself</strong></li>
						<li>In <strong>memory</strong> (data segment)</li>
						<li>At an <strong>I/O port</strong> (later)</li>
					</ol>
					<p style="margin-top: 30px; color: #FF9800;">We focus on 1‚Äì3 today</p>
				</section>

				<!-- ==================== 1. REGISTER ADDRESSING ==================== -->
				<section>
					<h2>1. Register Addressing</h2>
					<p>Data is <strong>inside the CPU</strong> ‚Üí Fastest!</p>
					<pre><code class="hljs" style="font-size: 0.85em;">
mov EAX, EBX
  </code></pre>
					<p style="margin-top: 15px;">Copies EBX ‚Üí EAX</p>
					<p style="color: #4CAF50;">No memory access</p>
				</section>

				<section>
					<h3>Register Examples</h3>
					<pre><code class="hljs" style="font-size: 0.8em;">
mov BX, CX     ; 16-bit
mov AL, CL     ; 8-bit
mov EDX, EAX   ; 32-bit
  </code></pre>
					<p style="font-size: 0.8em; margin-top: 20px;">All operands are in <strong>registers</strong></p>
				</section>

				<section>
					<h3>Quiz: Register Addressing</h3>
					<p>Which uses <strong>register addressing</strong>?</p>
					<select id="quiz-reg-1">
						<option value="">Select</option>
						<option value="yes">mov EAX, EBX</option>
						<option value="no">mov EAX, 100</option>
						<option value="no">mov EAX, [var]</option>
					</select>
					<br><br>
					<select id="quiz-reg-2">
						<option value="">Select</option>
						<option value="no">mov [mem], EAX</option>
						<option value="yes">mov ECX, EDX</option>
					</select>
					<button id="check-reg">Check</button>
					<p id="result-reg" style="margin-top: 10px; font-weight: bold;"></p>
				</section>

				<!-- ==================== 2. IMMEDIATE ADDRESSING ==================== -->
				<section>
					<h2>2. Immediate Addressing</h2>
					<p>Data is <strong>part of the instruction</strong></p>
					<pre><code class="hljs" style="font-size: 0.85em;">
mov AL, 75
  </code></pre>
					<p style="margin-top: 15px;">75 is <strong>inside</strong> the instruction</p>
					<p style="color: #2196F3;">Always a <strong>constant</strong></p>
				</section>

				<section>
					<h3>Immediate Examples</h3>
					<pre><code class="hljs" style="font-size: 0.8em;">
mov EAX, 42
mov BX, -5
mov CL, 'A'
  </code></pre>
					<p style="font-size: 0.8em; margin-top: 20px;">Can only be <strong>source</strong>, not destination
					</p>
				</section>

				<!-- Quiz: Immediate Mode (FIXED) -->
				<section>
					<h3>Quiz: Immediate Mode</h3>
					<p>Type the missing number to load 100 into EAX:</p>

					<div
						style="background:#1e1e1e; padding:15px; border-radius:8px; font-family:monospace; color:#d4d4d4; font-size:0.9em;">
						mov EAX,
						<input type="text" id="imm-input" placeholder="???" style="width:70px; font-family:monospace; font-size:1em; 
                  background:#2d2d2d; color:#d4d4d4; border:none; 
                  border-bottom:2px solid #569cd6; outline:none; text-align:center;">
					</div>

					<p style="margin-top:15px; color:#ccc;"><em>Should load 100 into EAX</em></p>
					<button id="check-imm" style="margin-top:10px;">Check</button>
					<p id="result-imm" style="margin-top:10px; font-weight:bold;"></p>
				</section>

				<!-- ==================== 3. MEMORY ADDRESSING ==================== -->
				<section>
					<h2>3. Memory Addressing</h2>
					<p>Data is in <strong>RAM</strong> (data segment)</p>
					<p style="color: #F44336;">Slower than registers</p>
					<p style="margin-top: 20px;">We need: <strong>Segment + Offset</strong></p>
					<p style="font-size: 0.8em;">DS register has segment ‚Üí we give <strong>offset</strong></p>
				</section>

				<!-- Direct Addressing -->
				<section>
					<h2>Direct Addressing</h2>
					<p>Use <strong>variable name</strong> ‚Üí offset</p>
					<pre><code class="hljs" style="font-size: 0.8em;">
response DB 'Y'
...
mov AL, [response]   ; AL = 'Y'
  </code></pre>
					<p style="color: #4CAF50;">[ ] means "go to memory"</p>
				</section>

				<section>
					<h3>Direct Addressing Examples</h3>
					<pre><code class="hljs" style="font-size: 0.75em;">
table1 TIMES 20 DD 0
...
mov [table1], 56     ; table1[0] = 56
mov EBX, [table1]    ; EBX = first value
  </code></pre>
					<p style="font-size: 0.8em;">NASM: <code>mov EBX, table1</code> ‚Üí address</p>
				</section>

				<section>
					<h3>Quiz: Direct Addressing</h3>
					<p>Fix the code to store 'N':</p>
					<div
						style="background:#1e1e1e; padding:15px; border-radius:8px; font-family:monospace; color:#d4d4d4; font-size:0.9em;">
						response DB 'Y'<br>
						mov &nbsp;
						<input type="text" id="direct-dest" placeholder="???" style="width:70px; font-family:monospace; font-size:1em; 
                  background:#2d2d2d; color:#d4d4d4; border:none; 
                  border-bottom:2px solid #569cd6; outline:none; text-align:center;">, 'N'
					</div>


					<button id="check-direct">Check</button>
					<p id="result-direct" style="font-weight: bold;"></p>
				</section>

				<!-- Indirect Addressing -->
				<section>
					<h2>Indirect Addressing</h2>
					<p><strong>Offset is in a register</strong></p>
					<pre><code class="hljs" style="font-size: 0.8em;">
mov EBX, table1
mov [EBX], 100
  </code></pre>
					<p>EBX acts like a <strong>pointer</strong></p>
				</section>

				<section>
					<h3>Access Array Elements</h3>
					<pre><code class="hljs" style="font-size: 0.75em;">
mov EBX, table1
mov [EBX], 100     ; table1[0]
add EBX, 4
mov [EBX], 99      ; table1[1]
  </code></pre>
					<p style="color: #FF9800;">+4 because DD = 4 bytes</p>
				</section>

				<section>
					<h3>Quiz: Indirect Array</h3>
					<p>Set <code>table1[2] = 200</code></p>
					<div
						style="background:#1e1e1e; padding:15px; border-radius:8px; font-family:monospace; color:#d4d4d4; font-size:0.9em;">
						mov EBX, table1<br>
						add EBX,
						<input type="text" id="indirect-offset" placeholder="???" style="width:70px; font-family:monospace; font-size:1em; 
                  background:#2d2d2d; color:#d4d4d4; border:none; 
                  border-bottom:2px solid #569cd6; outline:none; text-align:center;">
						<br>
						mov [EBX], 200
					</div>

					<button id="check-indirect">Check</button>
					<p id="result-indirect" style="font-weight: bold;"></p>
				</section>

				<!-- lea vs mov -->
				<section>
					<h2>lea = Load Effective Address</h2>
					<pre><code class="hljs" style="font-size: 0.8em;">
lea EBX, [table1]     ; EBX = address
mov EBX, table1       ; same, but faster
  </code></pre>
					<p style="font-size: 0.8em;">Use <code>mov</code> when possible</p>
				</section>

				<section>
					<h2>When LEA is Used</h2>
					<pre><code class="hljs" style="font-size: 0.8em;">
lea EAX, [EBX + 8]        ; pointer arithmetic
lea ECX, [EDI + ESI*4]    ; scaled index
lea EDX, [table1 + 16]    ; offset inside structures
    </code></pre>
					<p style="font-size: 0.8em;">
						Pentium can compute complex address expressions only using <code>LEA</code>,
						not with <code>MOV</code>.
					</p>
				</section>

				<section>
					<h2>When MOV Is Better</h2>
					<ul style="font-size: 0.85em;">
						<li>When loading a simple address:</li>
						<pre><code class="hljs" style="font-size: 0.8em;">
mov EBX, table1        ; faster & simpler
        </code></pre>
						<li>When copying registers:</li>
						<pre><code class="hljs" style="font-size: 0.8em;">
mov ECX, EDX           ; ideal for Pentium
        </code></pre>
						<li>When loading immediate values:</li>
						<pre><code class="hljs" style="font-size: 0.8em;">
mov EAX, 100
        </code></pre>
						<li>MOV = fastest instruction for simple data movement on Pentium</li>
					</ul>
				</section>

				<section>
					<h2>LEA vs MOV: Pentium Cost</h2>
					<ul style="font-size: 0.85em;">
						<li><b>MOV reg, label</b></li>
						<ul>
							<li>1 cycle (fastest)</li>
						</ul>

						<li><b>LEA reg, [label]</b></li>
						<ul>
							<li>1 cycle (same speed)</li>
							<li>No memory read ‚Üí avoids cache penalties</li>
						</ul>

						<li><b>LEA reg, [reg + reg*scale]</b></li>
						<ul>
							<li>1 cycle ‚Üí Pentium has a dedicated AGU (Address Generation Unit)</li>
							<li>Equivalent MOV+ADD sequence = 3 cycles</li>
						</ul>
					</ul>
				</section>




				<!-- Mixed Mode -->
				<section>
					<h2>Mixed Mode Example</h2>
					<pre><code class="hljs" style="font-size: 0.8em;">
mov AL, 75           ; immediate ‚Üí register
mov [response], AL   ; register ‚Üí memory
  </code></pre>
					<p style="color: #9C27B0;">Combines modes</p>
				</section>

				<!-- Big Quiz: Identify Mode -->
				<section>
					<h2>Big Quiz: Identify Addressing Mode</h2>
					<p>For each instruction, pick the mode:</p>
					<ol style="font-size: 0.8em;">
						<li><code>mov EAX, EBX</code>
							<select id="mode-1">
								<option value="">?</option>
								<option>Register</option>
								<option>Immediate</option>
								<option>Direct</option>
								<option>Indirect</option>
							</select>
						</li>
						<li><code>mov ECX, 10</code>
							<select id="mode-2">
								<option value="">?</option>
								<option>Register</option>
								<option>Immediate</option>
								<option>Direct</option>
								<option>Indirect</option>
							</select>
						</li>
						<li><code>mov [var], 5</code>
							<select id="mode-3">
								<option value="">?</option>
								<option>Register</option>
								<option>Immediate</option>
								<option>Direct</option>
								<option>Indirect</option>
							</select>
						</li>
						<li><code>mov EBX, table1</code>
							<select id="mode-4">
								<option value="">?</option>
								<option>Register</option>
								<option>Immediate</option>
								<option>Direct</option>
								<option>Indirect</option>
							</select>
						</li>
						<li><code>mov [EBX], 99</code>
							<select id="mode-5">
								<option value="">?</option>
								<option>Register</option>
								<option>Immediate</option>
								<option>Direct</option>
								<option>Indirect</option>
							</select>
						</li>
					</ol>
					<button id="check-big">Check All</button>
					<p id="result-big" style="font-weight: bold; margin-top: 10px;"></p>
				</section>

				<!-- Summary -->
				<section>
					<h2>Summary: Addressing Modes</h2>
					<table style="font-size: 0.85em; margin: auto;">
						<tr>
							<th>Mode</th>
							<th>Data Location</th>
							<th>Example</th>
						</tr>
						<tr>
							<td>Register</td>
							<td>CPU Register</td>
							<td><code>mov EAX, EBX</code></td>
						</tr>
						<tr>
							<td>Immediate</td>
							<td>In Instruction</td>
							<td><code>mov AL, 75</code></td>
						</tr>
						<tr>
							<td>Direct</td>
							<td>Memory (by name)</td>
							<td><code>mov [var], 1</code></td>
						</tr>
						<tr>
							<td>Indirect</td>
							<td>Memory (by register)</td>
							<td><code>mov [EBX], 99</code></td>
						</tr>
					</table>
				</section>

				<!-- Final Quiz: Write Code -->
				<section>
					<h2>Final Challenge</h2>
					<p>Write code to set <code>scores[3] = 95</code></p>
					<p>Given: <code>scores TIMES 10 DD 0</code></p>
					<textarea id="final-code"
						style="width: 100%; height: 120px; font-family: monospace; font-size: 0.8em;">
mov EBX, scores
add EBX, ??
mov [EBX], 95
  </textarea>
					<button id="check-final">Check</button>
					<p id="result-final" style="font-weight: bold;"></p>
				</section>

				<!-- ==================== JAVASCRIPT ==================== -->
				<script>
					document.addEventListener('DOMContentLoaded', function () {
						// Quiz: Register
						document.getElementById('check-reg')?.addEventListener('click', () => {
							const a1 = document.getElementById('quiz-reg-1').value;
							const a2 = document.getElementById('quiz-reg-2').value;
							const r = document.getElementById('result-reg');
							if (a1 === 'yes' && a2 === 'yes') {
								r.textContent = 'Correct! Both are register mode.'; r.style.color = 'green';
							} else {
								r.textContent = 'Try again. Register = both in CPU.'; r.style.color = 'red';
							}
						});

						// Quiz: Immediate
						document.getElementById('check-imm')?.addEventListener('click', () => {
							const val = document.getElementById('imm-input').value.trim();
							const r = document.getElementById('result-imm');
							if (val === '100') {
								r.textContent = 'Correct!'; r.style.color = 'green';
							} else {
								r.textContent = 'No ‚Äî use 100'; r.style.color = 'red';
							}
						});

						// Quiz: Direct
						document.getElementById('check-direct')?.addEventListener('click', () => {
							const val = document.getElementById('direct-dest').value.trim();
							const r = document.getElementById('result-direct');
							if (val === '[response]' || val === '[ response ]') {
								r.textContent = 'Correct! Use [ ] for memory.'; r.style.color = 'green';
							} else {
								r.textContent = 'Use [response]'; r.style.color = 'red';
							}
						});

						// Quiz: Indirect
						document.getElementById('check-indirect')?.addEventListener('click', () => {
							const val = document.getElementById('indirect-offset').value;
							const r = document.getElementById('result-indirect');
							if (val === '8') {
								r.textContent = 'Correct! 2 √ó 4 = 8'; r.style.color = 'green';
							} else {
								r.textContent = 'Hint: index 2 ‚Üí 2√ó4 = 8'; r.style.color = 'red';
							}
						});

						// Big Quiz
						document.getElementById('check-big')?.addEventListener('click', () => {
							const answers = {
								'mode-1': 'Register',
								'mode-2': 'Immediate',
								'mode-3': 'Direct',
								'mode-4': 'Direct',
								'mode-5': 'Indirect'
							};
							let correct = 0;
							let total = 5;
							for (let i = 1; i <= total; i++) {
								if (document.getElementById('mode-' + i).value === answers['mode-' + i]) correct++;
							}
							const r = document.getElementById('result-big');
							if (correct === total) {
								r.textContent = 'Perfect! All correct.'; r.style.color = 'green';
							} else {
								r.textContent = `Got ${correct}/${total}. Review modes.`; r.style.color = 'red';
							}
						});

						// Final Challenge
						document.getElementById('check-final')?.addEventListener('click', () => {
							const code = document.getElementById('final-code').value;
							const r = document.getElementById('result-final');
							if (code.includes('add EBX, 12') || code.includes('add EBX,12')) {
								r.textContent = 'Correct! 3 √ó 4 = 12'; r.style.color = 'green';
							} else {
								r.textContent = 'Use add EBX, 12 (3√ó4)'; r.style.color = 'red';
							}
						});
					});
				</script>
			</section>

			<section>
				<!-- ==================== Data Transfer Instructions ==================== -->
				<section>
					<h2>Data Transfer Instructions</h2>
					<p class="fragment">Today we cover the three most common ones on Pentium:</p>
					<ul style="margin-top: 30px; font-size: 0.9em;">
						<li class="fragment">MOV ‚Üí copy data</li>
						<li class="fragment">XCHG ‚Üí swap data</li>
						<li class="fragment">XLAT ‚Üí table lookup (translate)</li>
					</ul>
					<p class="fragment" style="margin-top: 40px; color: #FF9800; font-weight: bold;">Let‚Äôs start with
						the MOV</p>
				</section>

				<!-- ==================== The MOV Instruction ==================== -->
				<section>
					<h2>The MOV Instruction</h2>
					<p style="font-size: 1.1em;"><code>mov destination, source</code></p>
					<p class="fragment" style="margin-top: 20px;">Copies source ‚Üí destination<br><strong>Source is NOT
							changed</strong></p>
					<p class="fragment" style="color: #4CAF50; margin-top: 30px;">Both operands must be the <strong>same
							size</strong></p>
				</section>

				<section>
					<h2>5 Allowed Forms of MOV</h2>
					<table style="font-size: 0.85em; margin: auto;">
						<tr>
							<th>Form</th>
							<th>Example</th>
						</tr>
						<tr>
							<td>reg ‚Üê reg</td>
							<td><code>mov EAX, EBX</code></td>
						</tr>
						<tr>
							<td>reg ‚Üê immediate</td>
							<td><code>mov ECX, 100</code></td>
						</tr>
						<tr>
							<td>mem ‚Üê immediate</td>
							<td><code>mov BYTE [flag], 1</code></td>
						</tr>
						<tr>
							<td>reg ‚Üê mem</td>
							<td><code>mov EDX, [total]</code></td>
						</tr>
						<tr>
							<td>mem ‚Üê reg</td>
							<td><code>mov [result], EAX</code></td>
						</tr>
					</table>
					<p style="margin-top: 30px; color: #F44336;">Memory ‚Üí Memory is <strong>NOT allowed</strong></p>
				</section>

				<section>
					<h3>MOV Examples (Variety)</h3>
					<pre><code class="hljs" style="font-size: 0.8em;">
mov AL, 'A'          ; immediate ‚Üí 8-bit reg
mov BX, 5000h        ; immediate ‚Üí 16-bit reg
mov EDX, 0FFFFFFFFh   ; immediate ‚Üí 32-bit reg

mov [count], 0       ; immediate ‚Üí memory (with type!)
mov BH, CL           ; 8-bit register ‚Üí register
mov ESI, [table1]    ; memory ‚Üí register
mov [name1+4], 'K'   ; register ‚Üí memory offset
    </code></pre>
				</section>

				<section>
					<h3>Quick Quiz: Valid or Invalid?</h3>
					<p>Which of these are <strong>legal</strong> MOV instructions?</p>
					<select id="q1">
						<option value="">Select</option>
						<option>mov EAX, EBX</option>
						<option>mov [var1], [var2]</option>
						<option>mov AL, 300</option>
					</select>
					<br><br>
					<select id="q2">
						<option value="">Select</option>
						<option>mov BYTE [flag], 1</option>
						<option>mov DS, AX</option>
						<option>mov [EBX], EAX</option>
					</select>
					<button id="check-mov1">Check</button>
					<p id="res-mov1" style="margin-top:10px; font-weight:bold;"></p>
				</section>

				<!-- ==================== Ambiguous Moves & Type Specifiers ==================== -->
				<section>
					<h2>Ambiguous Moves</h2>
					<p>Sometimes the assembler doesn‚Äôt know the size‚Ä¶</p>
					<pre><code class="hljs" style="font-size: 0.8em;">
mov [EBX], 100     ; Is 100 a BYTE or WORD or DWORD?
    </code></pre>
					<p class="fragment" style="color: #FF572C;">Error or wrong size!</p>
				</section>

				<section>
					<h2>Solution: Type Specifiers</h2>
					<table style="font-size: 0.9em;">
						<tr>
							<th>Specifier</th>
							<th>Size</th>
						</tr>
						<tr>
							<td>BYTE</td>
							<td>1 byte</td>
						</tr>
						<tr>
							<td>WORD</td>
							<td>2 bytes</td>
						</tr>
						<tr>
							<td>DWORD</td>
							<td>4 bytes</td>
						</tr>
						<tr>
							<td>QWORD</td>
							<td>8 bytes</td>
						</tr>
						<tr>
							<td>TBYTE</td>
							<td>10 bytes</td>
						</tr>
					</table>
					<pre class="fragment" style="margin-top:20px;"><code class="hljs" style="font-size: 0.8em;">
mov BYTE  [EBX], 100    ; safe
mov WORD  [ESI], 100
mov DWORD [EDI], 100
    </code></pre>
				</section>

				<!-- ==================== Type Specifier Quiz (Fixed & Clean) ==================== -->
				<section>
					<h2>Type Specifier Quiz</h2>
					<p>Fix the line to store the number <strong>65</strong> as a <strong>byte</strong> in memory:</p>

					<div
						style="background:#1e1e1e; padding:25px; border-radius:12px; margin:30px auto; width:85%; font-family:monospace; font-size:1.1em; color:#d4d4d4; text-align:center;">
						mov <input type="text" id="type-part" placeholder="BYTE"
							style="width:100px; padding:8px; font-family:monospace; font-size:1em; background:#0d47a1; color:white; border:none; border-radius:6px; text-align:center;">
						[score],
						<input type="text" id="value-part" placeholder="65" value="65"
							style="width:80px; padding:8px; font-family:monospace; font-size:1em; background:#1565c0; color:white; border:none; border-radius:6px; text-align:center; margin-left:10px;">
					</div>

					<button id="check-type-quiz" style="margin-top:20px; padding:10px 20px; font-size:1em;">Check
						Answer</button>
					<p id="result-type" style="margin-top:20px; font-weight:bold; font-size:1.2em;"></p>
				</section>

				<script>
					document.addEventListener('DOMContentLoaded', () => {
						document.getElementById('check-type-quiz').addEventListener('click', () => {
							const typeInput = document.getElementById('type-part').value.trim();
							const valueInput = document.getElementById('value-part').value.trim();
							const result = document.getElementById('result-type');

							const typeOk = ['BYTE', 'byte', 'Byte'].includes(typeInput);
							const valueOk = valueInput === '65';

							if (typeOk && valueOk) {
								result.textContent = 'Perfect! mov BYTE [score], 65';
								result.style.color = '#4caf50';
							} else {
								result.textContent = 'Use BYTE and 65';
								result.style.color = '#f44336';
							}
						});

						// Optional: press Enter to check
						['type-part', 'value-part'].forEach(id => {
							document.getElementById(id).addEventListener('keypress', e => {
								if (e.key === 'Enter') document.getElementById('check-type-quiz').click();
							});
						});
					});
				</script>

				<!-- ==================== XCHG Instruction ==================== -->
				<section>
					<h2>The XCHG Instruction</h2>
					<p><code>xchg operand1, operand2</code></p>
					<p class="fragment" style="margin-top:20px; color:#4CAF50;">Swaps the contents of two operands</p>
					<p class="fragment" style="margin-top:30px;">Sizes: 8-bit, 16-bit, or 32-bit</p>
				</section>

				<section>
					<h3>XCHG Examples</h3>
					<pre><code class="hljs" style="font-size: 0.8em;">
xchg EAX, EDX          ; swap two 32-bit registers
xchg AL, BL            ; swap bytes
xchg [total], DX       ; swap memory word with DX
xchg AH, [flag]        ; high byte of AX ‚Üî memory byte
    </code></pre>
					<p style="color:#F44336;">Memory ‚Üî Memory ‚Üí <strong>illegal</strong></p>
				</section>

				<section>
					<h3>Why XCHG is Awesome</h3>
					<p>Swap without a temporary register!</p>
					<pre><code class="hljs" style="font-size: 0.75em;">
; Old way (3 instructions)
mov  ECX, EAX
mov  EAX, EDX
mov  EDX, ECX

; New way (1 instruction!)
xchg EAX, EDX
    </code></pre>
					<p style="color:#4CAF50;">Perfect for sorting algorithms</p>
				</section>

				<section>
					<h3>Endian Conversion Trick</h3>
					<pre><code class="hljs" style="font-size: 0.8em;">
; Convert AX from little-endian ‚Üî big-endian
xchg AL, AH
    </code></pre>
					<p class="fragment">For 32-bit ‚Üí use <code>bswap EAX</code></p>
				</section>

				<section>
					<h3>XCHG Quiz</h3>
					<p>How many instructions to swap EAX and EBX using only MOV?</p>
					<input type="text" id="xchg-count" placeholder="?"
						style="width:60px; text-align:center; font-family:monospace;">
					<button id="check-xchg">Check</button>
					<p id="res-xchg" style="font-weight:bold;"></p>
				</section>

				<!-- ==================== XLAT ‚Äì Part 1: What is it? ==================== -->
				<section>
					<h2>The XLAT Instruction</h2>
					<p style="font-size:1.1em; margin:30px 0;"><code>xlatb</code> ‚Üí "translate byte"</p>

					<p style="font-style:italic; color:#81d4fa;">It turns a number into something else using a lookup
						table</p>

					<div style="margin:40px auto; text-align:center;">
						<div
							style="display:inline-block; background:#0d47a1; padding:20px; border-radius:12px; color:white; font-size:1.3em;">
							AL = 5
						</div>
						<span style="font-size:2em; margin:0 30px;">‚Üí</span>
						<div
							style="display:inline-block; background:#1b5e20; padding:20px; border-radius:12px; color:white; font-size:1.3em;">
							xlatb
						</div>
						<span style="font-size:2em; margin:0 30px;">‚Üí</span>
						<div
							style="display:inline-block; background:#2e7d32; padding:20px; border-radius:12px; color:white; font-size:1.3em;">
							AL = 'F'
						</div>
					</div>

					<p style="margin-top:40px; color:#ff9800;">Think: "What should 5 become? ‚Üí look it up!</p>
				</section>

				<!-- ==================== XLAT ‚Äì Part 2: How it works ==================== -->
				<!-- ==================== XLAT ‚Äì How it really works (perfectly visible) ==================== -->
				<!-- ==================== XLAT ‚Äì How It Works (Final Perfect Version) ==================== -->
				<!-- XLAT ‚Äì How It Works (100% safe for all screens) -->
				<section>
					<h3>How XLAT Works</h3>

					<div style="background:#0d1117; color:#79c0ff; padding:12px; border-radius:8px;
              font-family:monospace; font-size:1em; margin:15px auto; width:75%;">
						hex_table DB '0123456789ABCDEF'
					</div>

					<p style="text-align:center; font-size:1em; color:#8be9fd; margin:20px 0 10px;">
						EBX = address of the table
					</p>

					<!-- Smaller arrow and reduced spacing -->
					<div style="text-align:center; font-size:1.5em; color:#ffd43b; margin:5px 0;">
						‚Üì
					</div>

					<div style="background:#1f6feb; color:white; padding:10px 16px; border-radius:8px;
              font-family:monospace; font-size:1em; margin:15px auto; width:60%;">
						mov EBX, hex_table
					</div>

					<div style="background:#161b22; color:#c9d1d9; padding:14px; border-radius:8px;
              font-family:monospace; font-size:1em; margin:20px auto; width:70%;">
						mov AL, 10 ; index 10 ‚Üí 'A'<br>
						<span style="color:#50fa7b; font-weight:bold;">xlatb</span> ; AL ‚Üê table[AL] = 'A'
					</div>

					<p style="text-align:center; font-size:1em; color:#ff79c6; margin-top:20px;">
						Rule: <strong>xlatb</strong> ‚Üí AL = table[AL]
					</p>
				</section>


				<!-- ==================== XLAT ‚Äì Part 3: Interactive Quiz ==================== -->
				<section>
					<h3>XLAT Quiz ‚Äì Can You Do It?</h3>
					<p>Complete the code so that after <code>xlatb</code>, AL contains <strong>'9'</strong></p>

					<pre style="background:#111; color:#d4d4d4; padding:20px; border-radius:10px; font-size:0.9em;">
digits_table  DB '012345359638345'

    mov  EBX, <input type="text" id="ans1" placeholder="???" 
                     style="width:140px; padding:6px; background:#0d47a1; color:white; border:none; border-radius:4px; text-align:center;">
    mov  AL,  <input type="text" id="ans2" placeholder="???" 
                     style="width:60px; padding:6px; background:#1565c0; color:white; border:none; border-radius:4px; text-align:center;">
    xlatb
  </pre>

					<button id="check-xlat" style="margin-top:20px; padding:10px 20px; font-size:1em;">Check
						Answer</button>
					<p id="xlat-result" style="margin-top:20px; font-weight:bold; font-size:1.2em;"></p>
				</section>

				<script>
					document.addEventListener('DOMContentLoaded', () => {
						document.getElementById('check-xlat')?.addEventListener('click', () => {
							const a1 = document.getElementById('ans1').value.trim();
							const a2 = document.getElementById('ans2').value.trim();
							const res = document.getElementById('xlat-result');

							const ok1 = /digits?_?table/i.test(a1);
							const ok2 = a2 === '8';

							if (ok1 && ok2) {
								res.textContent = 'Correct! AL becomes "9"';
								res.style.color = '#4caf50';
							} else {
								res.textContent = 'EBX = digits_table, AL is the index of 9';
								res.style.color = '#f44336';
							}
						});
					});
				</script>

				<!-- ==================== XLAT Instruction ==================== -->
				<section>
					<h2>The XLAT Instruction Summary</h2>
					<p style="margin-top:20px;">Replaces AL with table[AL]</p>
					<ul style="font-size:0.9em;">
						<li>EBX = base address of translation table</li>
						<li>AL = index (0‚Äì255)</li>
						<li>After xlatb ‚Üí AL = table[old_AL]</li>
					</ul>
				</section>

				<section>
					<h3>XLAT Example ‚Äì Hex to ASCII</h3>
					<pre><code class="hljs" style="font-size: 0.75em;">
hex_table DB 'ABCDEF0123456789'

mov  EBX, hex_table
mov  AL, 00h          ; we want 'A'
xlatb                 ; AL ‚Üê 'A' (41h)
    </code></pre>
					<p>Common in old BIOS/video routines and checksum displays</p>
				</section>


				<!-- ==================== Summary ==================== -->
				<section>
					<h2>Summary Table</h2>
					<table style="font-size: 0.88em; margin:auto;">
						<tr>
							<th>Instruction</th>
							<th>Purpose</th>
							<th>Key Restriction</th>
						</tr>
						<tr>
							<td>MOV</td>
							<td>Copy</td>
							<td>No mem‚Üímem, same size</td>
						</tr>
						<tr>
							<td>XCHG</td>
							<td>Swap</td>
							<td>No mem‚Üîmem</td>
						</tr>
						<tr>
							<td>XLATB</td>
							<td>Table lookup</td>
							<td>Only 256-entry byte table</td>
						</tr>
					</table>
				</section>


				<!-- ==================== JavaScript for Quizzes ==================== -->
				<script>
					document.addEventListener('DOMContentLoaded', function () {

						// MOV valid/invalid quiz
						document.getElementById('check-mov1').onclick = function () {
							const a1 = document.getElementById('q1').value;
							const a2 = document.getElementById('q2').value;
							const r = document.getElementById('res-mov1');
							if (a1 === 'mov EAX, EBX' && (a2 === 'mov BYTE [flag], 1' || a2 === 'mov [EBX], EAX')) {
								r.textContent = 'Correct!'; r.style.color = 'green';
							} else {
								r.textContent = 'One or both are illegal'; r.style.color = 'red';
							}
						};


						// XCHG count quiz
						document.getElementById('check-xchg').onclick = function () {
							const v = document.getElementById('xchg-count').value.trim();
							const r = document.getElementById('res-xchg');
							if (v === '3') { r.textContent = 'Yes!'; r.style.color = 'green'; }
							else { r.textContent = 'It takes 3 MOVs'; r.style.color = 'red'; }
						};
					});
				</script>
			</section>



			<!-- ========================================================= -->
			<!-- ===============  ARITHMETIC INSTRUCTIONS  =============== -->
			<!-- ========================================================= -->
			<section>

				<!-- ==================== Title Slide ==================== -->
				<section>
					<h1>Arithmetic Instructions</h1>
					<p style="margin-top:20px; font-size:1.2em;">INC ‚Ä¢ DEC ‚Ä¢ ADD ‚Ä¢ SUB ‚Ä¢ CMP</p>
					<p class="fragment" style="color:#00e676; font-weight:bold; margin-top:40px;">
						Fast operations used everywhere in Assembly
					</p>
				</section>

				<!-- ==================== INC / DEC ==================== -->
				<section>
					<h2>INC & DEC</h2>
					<p>INC ‚Üí add 1<br>DEC ‚Üí subtract 1</p>

					<div style="margin-top:25px;">
						<pre><code class="hljs" style="font-size:0.9em;">
inc EBX      ; EBX = EBX + 1
dec DL       ; DL = DL - 1
      </code></pre>
					</div>

					<p class="fragment" style="color:#ff9800; margin-top:25px;">
						‚ùó Immediate operands are NOT allowed (inc 5 ‚Üí illegal)
					</p>
				</section>

				<!-- INC/DEC Anim Example -->
				<section>
					<h3>Example: INC / DEC Simulation</h3>

					<div style="background:#111; padding:20px; border-radius:10px; width:60%; margin:auto;">
						<p style="font-family:monospace; font-size:1.1em; color:#80cbc4;">
							EBX = <span id="ebx-val">1057h</span>
						</p>

						<button onclick="incEBX()" style="padding:10px 20px; margin-top:10px;">INC EBX</button>
						<button onclick="decEBX()" style="padding:10px 20px; margin-left:10px;">DEC EBX</button>
					</div>

					<script>
						let ebx = 0x1057;
						function incEBX() {
							ebx = (ebx + 1) & 0xFFFF;
							document.getElementById("ebx-val").textContent = ebx.toString(16).toUpperCase() + "h";
						}
						function decEBX() {
							ebx = (ebx - 1) & 0xFFFF;
							document.getElementById("ebx-val").textContent = ebx.toString(16).toUpperCase() + "h";
						}
					</script>
				</section>

				<!-- INC/DEC Exercise -->
				<section>
					<h3>Exercise: What Happens?</h3>
					<p style="font-size:1.1em;">EBX = FFFFh</p>

					<p>After <b>inc EBX</b>, EBX = ?</p>

					<input id="inc-q1" placeholder="Answer" style="padding:8px; text-align:center;">
					<button onclick="checkINC()">Check</button>
					<p id="inc-res" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkINC() {
							let v = document.getElementById("inc-q1").value.trim().toLowerCase();
							if (v === "0000h" || v === "0000") {
								document.getElementById("inc-res").textContent = "Correct!";
								document.getElementById("inc-res").style.color = "green";
							} else {
								document.getElementById("inc-res").textContent = "Nope! It wraps to 0000h";
								document.getElementById("inc-res").style.color = "red";
							}
						}
					</script>
				</section>

				<!-- ==================== ADD Instruction ==================== -->
				<section>
					<h2>ADD Instruction</h2>
					<p>Adds two same-sized operands</p>

					<div style="margin-top:25px;">
						<pre><code class="hljs" style="font-size:0.85em;">
add AX, DX      ; AX = AX + DX
add BL, CH      ; BL = BL + CH
add [value], 10 ; memory = memory + 10
      </code></pre>
					</div>

					<p class="fragment" style="color:#4caf50; margin-top:20px;">
						INC EAX is same speed as ADD EAX,1 ‚Üí but shorter!
					</p>
				</section>

				<!-- ADD Table Exercise -->
				<section>
					<h3>ADD: Fill in the Result</h3>

					<p>AX = 1052h, DX = AB62h</p>

					<p style="margin-top:10px;">After <b>add AX, DX</b> ‚Üí AX = ?</p>

					<input id="add1" placeholder="Answer" style="padding:8px; text-align:center;">
					<button onclick="checkADD()">Check</button>

					<p id="add-res" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkADD() {
							let v = document.getElementById("add1").value.trim().toLowerCase();
							if (v === "bbb4h" || v === "bbb4") {
								document.getElementById("add-res").textContent = "Correct!";
								document.getElementById("add-res").style.color = "green";
							} else {
								document.getElementById("add-res").textContent = "Correct answer ‚Üí BBB4h";
								document.getElementById("add-res").style.color = "red";
							}
						}
					</script>
				</section>

				<!-- ==================== SUB Instruction ==================== -->
				<section>
					<h2>SUB Instruction</h2>
					<p>Subtracts source from destination</p>

					<pre><code class="hljs" style="font-size:0.85em;">
sub AX, DX   ; AX = AX - DX
sub BL, CH   ; BL = BL - CH
      </code></pre>

					<p class="fragment" style="color:#FF9800; margin-top:20px;">
						Like ADD ‚Üí sizes must match
					</p>
				</section>

				<!-- SUB Exercise -->
				<section>
					<h3>SUB Exercise</h3>
					<p>AX = 1052h, DX = AB62h</p>

					<p>After <b>sub AX, DX</b> ‚Üí AX = ?</p>

					<input id="sub1" placeholder="Answer" style="padding:8px; text-align:center;">
					<button onclick="checkSUB()">Check</button>
					<p id="sub-res" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkSUB() {
							let v = document.getElementById("sub1").value.trim().toLowerCase();
							if (v === "64f0h" || v === "64f0") {
								document.getElementById("sub-res").textContent = "Correct!";
								document.getElementById("sub-res").style.color = "green";
							} else {
								document.getElementById("sub-res").textContent = "Correct answer ‚Üí 64F0h";
								document.getElementById("sub-res").style.color = "red";
							}
						}
					</script>
				</section>

				<!-- ==================== CMP Instruction ==================== -->
				<section>
					<h2>CMP Instruction</h2>
					<p>cmp A, B ‚Üí performs A - B but does <b>not store</b> the result.</p>

					<div style="margin-top:25px;">
						<pre><code class="hljs" style="font-size:0.85em;">
cmp AX, BX    ; compare AX and BX
je equal      ; jump if equal
jg greater    ; jump if AX > BX
      </code></pre>
					</div>

					<p class="fragment" style="color:#00b0ff; margin-top:20px;">
						Used with conditional jumps
					</p>
				</section>

				<!-- CMP Logical Exercise -->
				<section>
					<h3>CMP Logic Quiz</h3>

					<p>AX = 30, BX = 20</p>
					<p>cmp AX, BX<br>jg NEXT</p>

					<select id="cmp-q" style="padding:8px;">
						<option value="">Will it jump?</option>
						<option value="yes">YES</option>
						<option value="no">NO</option>
					</select>

					<button onclick="checkCMP()">Check</button>

					<p id="cmp-res" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkCMP() {
							let v = document.getElementById("cmp-q").value;
							if (v === "yes") {
								document.getElementById("cmp-res").textContent = "Correct! 30 > 20";
								document.getElementById("cmp-res").style.color = "green";
							} else {
								document.getElementById("cmp-res").textContent = "Wrong! AX > BX ‚Üí jg executes";
								document.getElementById("cmp-res").style.color = "red";
							}
						}
					</script>
				</section>

				<!-- ==================== Summary Slide ==================== -->
				<section>
					<h2>Summary</h2>
					<table style="font-size:0.9em; margin:auto;">
						<tr>
							<th>Instruction</th>
							<th>Operation</th>
						</tr>
						<tr>
							<td>INC</td>
							<td>Add 1</td>
						</tr>
						<tr>
							<td>DEC</td>
							<td>Subtract 1</td>
						</tr>
						<tr>
							<td>ADD</td>
							<td>dest = dest + src</td>
						</tr>
						<tr>
							<td>SUB</td>
							<td>dest = dest - src</td>
						</tr>
						<tr>
							<td>CMP</td>
							<td>dest - src (no store)</td>
						</tr>
					</table>

					<p style="margin-top:25px; color:#4caf50; font-weight:bold;">
						Exercises improve understanding ‚Äî practice matters!
					</p>
				</section>


				<!-- ==================== Title Slide ==================== -->
				<section>
					<h1>Conditional Execution</h1>
					<p style="margin-top:20px; font-size:1.2em;">
						JMP ‚Ä¢ JE ‚Ä¢ JNE ‚Ä¢ JG ‚Ä¢ JL ‚Ä¢ JGE ‚Ä¢ JLE
					</p>
					<p class="fragment" style="color:#00e676; font-weight:bold; margin-top:30px;">
						Control the flow of your program
					</p>
				</section>

				<!-- ==================== Unconditional Jump ==================== -->
				<section>
					<h2>Unconditional Jump: JMP</h2>
					<p>Always jumps to the given label</p>

					<pre><code class="hljs" style="font-size:0.85em;">
mov EAX, 1
inc_again:
inc EAX
jmp inc_again  ; infinite loop
mov EBX, EAX   ; never executed
		</code></pre>

					<p class="fragment" style="color:#ff9800; margin-top:20px;">
						JMP ‚Üí always changes EIP (next instruction)
					</p>
				</section>

				<!-- ==================== Conditional Jump Intro ==================== -->
				<section>
					<h3>Conditional Jump: j&lt;cond&gt;</h3>
					<p>Jump only if a condition is true</p>
					<p class="fragment" style="margin-top:0px;">
						Usually tests flags set by <b>cmp</b> or arithmetic instructions
					</p>

					<div style="margin-top:0px;">
						<pre><code class="hljs" style="font-size:0.85em;">    xor  cx, cx                 ; CX = 0 (counter)

get_char:
    mov  ah, 01h                ; input with echo
    int  21h

    cmp  al, 0Dh                ; Enter pressed?
    je   finished

    inc  cx                    ; count the character
    jmp  get_char

finished:
    ; CX now holds how many characters were typed (excluding Enter)</code></pre>
					</div>
				</section>

				<!-- ==================== How CMP + Conditional Jump Works ==================== -->
				<section>
					<h3>CMP + JE Example</h3>
					<p>AL = 0DH ‚Üí ZF = 1</p>
					<p>AL ‚â† 0DH ‚Üí ZF = 0</p>

					<div style="margin-top:20px;">
						<pre><code class="hljs" style="font-size:0.85em;">
cmp AL, 0DH    ; AL - 0DH ‚Üí sets Zero Flag (ZF)
je CR_received ; jump if ZF = 1
			</code></pre>
					</div>

					<p class="fragment" style="color:#4caf50; margin-top:20px;">
						Flags retain their value until overwritten
					</p>
				</section>

				<section>
					<h1>CPU FLAGS Overview</h1>
					<p style="margin-top:20px; font-size:1.2em;">Learn how to calculate ZF, SF, CF, OF, AF, PF</p>
					<p class="fragment" style="color:#00e676; font-weight:bold; margin-top:30px;">
						Flags indicate results of arithmetic & logic operations
					</p>
				</section>

				<!-- ==================== Flags Table ==================== -->
				<section>
					<h2>Flags Table</h2>
					<table style="font-size:0.9em; margin:auto; margin-top:20px; border-collapse:collapse;">
						<tr>
							<th style="border:1px solid #ccc; padding:6px;">Flag</th>
							<th style="border:1px solid #ccc; padding:6px;">Meaning</th>
							<th style="border:1px solid #ccc; padding:6px;">Set When...</th>
						</tr>
						<tr>
							<td>ZF</td>
							<td>Zero Flag</td>
							<td>Result = 0</td>
						</tr>
						<tr>
							<td>SF</td>
							<td>Sign Flag</td>
							<td>Most significant bit = 1 (negative)</td>
						</tr>
						<tr>
							<td>CF</td>
							<td>Carry Flag</td>
							<td>Unsigned overflow (borrow/carry)</td>
						</tr>
						<tr>
							<td>OF</td>
							<td>Overflow Flag</td>
							<td>Signed overflow (result too big)</td>
						</tr>
						<tr>
							<td>AF</td>
							<td>Auxiliary Carry</td>
							<td>Carry from bit 3 to bit 4</td>
						</tr>
						<tr>
							<td>PF</td>
							<td>Parity Flag</td>
							<td>Even number of 1 bits ‚Üí PF=1</td>
						</tr>
					</table>
				</section>

				<!-- ==================== Flags Example 1 ==================== -->
				<section>
					<h3>Example: ADD 8-bit Numbers</h3>
					<p>Instruction: <code>ADD AL, BL</code></p>

					<pre><code class="hljs" style="font-size:0.80em;">AL = 0x7F   ; 0111 1111
BL = 0x01   ; 0000 0001
ADD AL, BL  ; AL = 0x80 ‚Üí 1000 0000</code></pre>
					<p class="fragment" style="margin-top:0px;">
						Which flags are set?
					</p>
					<ul class="fragment" style="margin-top:0px;">
						<li>ZF = 0 (result ‚â† 0)</li>
						<li>SF = 1 (MSB = 1 ‚Üí negative)</li>
						<li>CF = 0 (no unsigned carry out)</li>
						<li>OF = 1 (signed overflow: 127+1 ‚Üí -128)</li>
						<li>AF = 1 (carry from bit 3 to 4)</li>
						<li>PF = 0 (odd number of 1 bits)</li>
					</ul>
				</section>

				<!-- ==================== Flags Example 2 ==================== -->
				<section>
					<h3>Example: SUB 8-bit Numbers</h3>
					<p>Instruction: <code>SUB AL, BL</code></p>

					<pre><code class="hljs" style="font-size:0.85em;">AL = 0x05   ; 0000 0101
BL = 0x09   ; 0000 1001
SUB AL, BL  ; AL = 0xFC ‚Üí 1111 1100</code></pre>

					<p class="fragment" style="margin-top:10px;">
						Flags set:
					</p>
					<ul class="fragment" style="margin-top:10px;">
						<li>ZF = 0 (result ‚â† 0)</li>
						<li>SF = 1 (negative)</li>
						<li>CF = 1 (borrow for unsigned)</li>
						<li>OF = 0 (signed result correct)</li>
						<li>AF = 1 (borrow from bit 4)</li>
						<li>PF = 0 (odd number of 1 bits)</li>
					</ul>
				</section>

				<section style="overflow:auto; padding-bottom:20px;">
					<h3>Interactive Flags Exercise</h3>
					<p>AL = 0x0F, BL = 0x01 ‚Üí ADD AL, BL</p>

					<p>Which flags are set? (Yes/No)</p>
					<table style="font-size:0.50em; margin:auto; margin-top:0px; border-collapse: collapse;">
						<tr>
							<th>Flag</th>
							<th>Set?</th>
						</tr>
						<tr>
							<td>ZF</td>
							<td>
								<select id="f1">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>SF</td>
							<td>
								<select id="f2">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>CF</td>
							<td>
								<select id="f3">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>OF</td>
							<td>
								<select id="f4">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>AF</td>
							<td>
								<select id="f5">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>PF</td>
							<td>
								<select id="f6">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
					</table>

					<button id="check-flags" style="margin-top:15px; padding:6px 12px;">Check</button>
					<p id="flags-res" style="font-weight:bold; margin-top:10px;"></p>
				</section>
				<script>
					document.addEventListener('DOMContentLoaded', () => {
						const button = document.getElementById("check-flags");
						button.addEventListener("click", () => {
							// Correct answers for AL=0x0F + BL=0x01 ‚Üí 0x10
							const correctAnswers = ["No", "No", "No", "No", "Yes", "Yes"];
							const userAnswers = [
								document.getElementById("f1").value,
								document.getElementById("f2").value,
								document.getElementById("f3").value,
								document.getElementById("f4").value,
								document.getElementById("f5").value,
								document.getElementById("f6").value
							];

							let allCorrect = true;
							for (let i = 0; i < correctAnswers.length; i++) {
								if (userAnswers[i] !== correctAnswers[i]) {
									allCorrect = false;
									break;
								}
							}

							const res = document.getElementById("flags-res");
							if (allCorrect) {
								res.textContent = "All Correct! Well done!";
								res.style.color = "green";
							} else {
								res.textContent = "Some answers are wrong. Check ZF, SF, CF, OF, AF, PF.";
								res.style.color = "red";
							}
						});
					});
				</script>



				<section>
					<h3>Common Conditional Jumps</h3>
					<table style="font-size:0.80em; margin:auto; margin-top:20px; border-collapse: collapse;">
						<tr>
							<th>Instruction</th>
							<th>Condition</th>
							<th>When it jumps</th>
						</tr>
						<tr>
							<td>je / jz</td>
							<td>Zero flag = 1</td>
							<td>Jump if equal / result is zero</td>
						</tr>
						<tr>
							<td>jne / jnz</td>
							<td>Zero flag = 0</td>
							<td>Jump if not equal / result is non-zero</td>
						</tr>
						<tr>
							<td>jg</td>
							<td>ZF=0, SF=OF</td>
							<td>Jump if signed greater</td>
						</tr>
						<tr>
							<td>jl</td>
							<td>SF ‚â† OF</td>
							<td>Jump if signed less</td>
						</tr>
						<tr>
							<td>jge</td>
							<td>SF=OF</td>
							<td>Jump if signed greater or equal</td>
						</tr>
						<tr>
							<td>jle</td>
							<td>ZF=1 OR SF‚â†OF</td>
							<td>Jump if signed less or equal</td>
						</tr>
						<tr>
							<td>jc</td>
							<td>Carry flag = 1</td>
							<td>Jump if carry occurred</td>
						</tr>
						<tr>
							<td>jnc</td>
							<td>Carry flag = 0</td>
							<td>Jump if no carry</td>
						</tr>
					</table>
				</section>


				<!-- ==================== Flags Visual Example ==================== -->
				<section>
					<h3>Flags Example</h3>
					<p>AX = 5, BX = 10</p>
					<p>Instruction: <code>cmp AX, BX</code></p>

					<p class="fragment" style="margin-top:20px; font-style:italic; color:#81d4fa;">
						ZF = 0 (not equal), SF = 1 (negative result)
					</p>

					<p class="fragment" style="margin-top:20px;">
						je equal? ‚ùå ‚Üí no jump<br>
						jl smaller? ‚úÖ ‚Üí jump to 'smaller'
					</p>
				</section>

				<!-- ==================== Conditional Jump Interactive Exercise ==================== -->
				<section>
					<h3>Interactive Exercise</h3>
					<p>AX = 20, BX = 15<br>Instruction: <code>cmp AX, BX</code></p>

					<p>Which jumps will be taken?</p>
					<select id="cond-jump" style="padding:6px; margin-top:10px;">
						<option value="">Select</option>
						<option value="je">je</option>
						<option value="jg">jg</option>
						<option value="jl">jl</option>
						<option value="jne">jne</option>
					</select>

					<button onclick="checkCondJump()" style="margin-left:10px; padding:6px 12px;">Check</button>
					<p id="cond-res" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkCondJump() {
							const val = document.getElementById("cond-jump").value;
							const res = document.getElementById("cond-res");
							if (val === "jg" || val === "jne") {
								res.textContent = "Correct! ZF=0, SF=0 ‚Üí JG & JNE jump";
								res.style.color = "green";
							} else {
								res.textContent = "Incorrect, try again!";
								res.style.color = "red";
							}
						}
					</script>
				</section>

				<!-- ==================== Conditional Jump Table Exercise ==================== -->
				<section>
					<h3>Fill in the Action Table</h3>
					<p>Assume statement: <code>cmp AL, BL</code></p>

					<table style="font-size:0.85em; margin:auto; margin-top:20px; border-collapse: collapse;">
						<tr>
							<th style="border:1px solid #ccc; padding:4px;">Instruction</th>
							<th style="border:1px solid #ccc; padding:4px;">AL</th>
							<th style="border:1px solid #ccc; padding:4px;">BL</th>
							<th style="border:1px solid #ccc; padding:4px;">Jump?</th>
						</tr>
						<tr>
							<td>je go_back</td>
							<td>56H</td>
							<td>56H</td>
							<td>
								<select id="t1" style="width:60px;">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>jg go_back</td>
							<td>56H</td>
							<td>55H</td>
							<td>
								<select id="t2" style="width:60px;">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>jl go_back</td>
							<td>27H</td>
							<td>26H</td>
							<td>
								<select id="t3" style="width:60px;">
									<option value="">Select</option>
									<option>Yes</option>
									<option>No</option>
								</select>
							</td>
						</tr>
					</table>

					<button style="margin-top:15px; padding:6px 12px;" onclick="checkTableJump()">Check Answers</button>
					<p id="table-res" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkTableJump() {
							const a1 = document.getElementById("t1").value.trim().toLowerCase();
							const a2 = document.getElementById("t2").value.trim().toLowerCase();
							const a3 = document.getElementById("t3").value.trim().toLowerCase();
							const res = document.getElementById("table-res");

							if (a1 === "yes" && a2 === "yes" && a3 === "no") {
								res.textContent = "All Correct!";
								res.style.color = "green";
							} else {
								res.textContent = "Some answers are wrong! Hint: check ZF and SF flags.";
								res.style.color = "red";
							}
						}
					</script>
				</section>


				<!-- ==================== Summary Slide ==================== -->
				<section>
					<h2>Summary</h2>
					<ul style="font-size:0.9em; margin-top:20px;">
						<li><b>JMP</b> ‚Üí unconditional jump</li>
						<li><b>JE / JZ</b> ‚Üí jump if equal / zero</li>
						<li><b>JNE / JNZ</b> ‚Üí jump if not equal / not zero</li>
						<li><b>JG / JL / JGE / JLE</b> ‚Üí signed comparison jumps</li>
						<li><b>JC / JNC</b> ‚Üí carry flag</li>
						<li>Conditional jumps depend on FLAGS (ZF, SF, CF, OF)</li>
					</ul>
				</section>


				<!-- ==================== Iteration Instruction Section ==================== -->
				<section>
					<h2>Iteration with Loops</h2>
					<p>We can repeat a block of instructions multiple times using <strong>jump + counter</strong> or the
						<strong>LOOP</strong> instruction.
					</p>
				</section>

				<!-- ==================== Loop Using DEC + JNZ ==================== -->
				<section>
					<h3>Loop using DEC + JNZ</h3>
					<pre style="background:#111; color:#d4d4d4; padding:20px; border-radius:10px; font-size:0.9em;">
mov CL, 50       ; loop counter
repeat1:
    ; &lt;loop body&gt;
    dec CL
    jnz repeat1    ; jump if CL ‚â† 0
    </pre>
					<p>This executes the &lt;loop body&gt; 50 times. CL is decremented each iteration.</p>
				</section>

				<!-- ==================== Loop Instruction ==================== -->
				<section>
					<h3>LOOP Instruction</h3>
					<p>LOOP simplifies iteration by combining <code>DEC ECX</code> + <code>JNZ</code></p>
					<pre style="background:#111; color:#d4d4d4; padding:20px; border-radius:10px; font-size:0.9em;">mov ECX, 50       ; loop counter
repeat1:
    ; &lt;loop body&gt;
    loop repeat1    ; decrement ECX, jump if ECX ‚â† 0</pre>
					<p>ECX is used as the loop counter. LOOP automatically decrements and checks ECX.</p>
				</section>

				<!-- ==================== LOOP Example 1 ==================== -->
				<section>
					<h3>Example: Summing Numbers</h3>
					<pre style="background:#111; color:#d4d4d4; padding:20px; border-radius:10px; font-size:0.9em;">mov ECX, 5      ; loop 5 times
mov EAX, 0      ; sum accumulator
repeat_sum:
    add EAX, 2  ; add 2 each iteration
    loop repeat_sum
; After loop, EAX = 10</pre>
				</section>

				<!-- ==================== LOOP Example 2 ==================== -->
				<section>
					<h3>Example: Copy Array</h3>
					<pre style="background:#111; color:#d4d4d4; padding:20px; border-radius:10px; font-size:0.9em;">
mov ECX, 4          ; 4 elements
mov ESI, src_array  ; source array
mov EDI, dest_array ; destination array
copy_loop:
    mov AL, [ESI]    ; read byte from source
    mov [EDI], AL    ; write byte to destination
    inc ESI
    inc EDI
    loop copy_loop
    </pre>
				</section>

				<!-- ==================== Interactive Exercise ==================== -->
				<section>
					<h3>Exercise: Fill the Loop Counter</h3>
					<p>We want to repeat the loop <strong>10 times</strong>. Fill the ECX value:</p>

					<pre style="background:#111; color:#d4d4d4; padding:20px; border-radius:10px; font-size:0.9em;">
mov ECX, <input type="text" id="loop-ecx" placeholder="?" 
               style="width:50px; padding:4px; text-align:center; font-family:monospace;">
repeat1:
    ; &lt;loop body&gt;
    loop repeat1
    </pre>

					<button style="margin-top:10px; padding:6px 12px;" onclick="checkLoop()">Check</button>
					<p id="loop-result" style="font-weight:bold; margin-top:10px;"></p>

					<script>
						function checkLoop() {
							const val = document.getElementById("loop-ecx").value.trim();
							const res = document.getElementById("loop-result");
							if (val === "10") {
								res.textContent = "Correct! The loop will run 10 times.";
								res.style.color = "green";
							} else {
								res.textContent = "Try again! Remember ECX holds the loop count.";
								res.style.color = "red";
							}
						}
					</script>
				</section>

				<!-- ==================== Practice Problems ==================== -->
				<section>
					<h3>Practice Problems</h3>
					<ol>
						<li>Write a loop using <strong>LOOP</strong> that adds numbers 1 to 10 and stores the sum in
							EAX.</li>
						<li>Copy 8 bytes from memory location <code>src</code> to <code>dest</code> using a loop.</li>
						<li>Use a loop to decrement a value in EBX from 20 down to 0.</li>
						<li>Write a loop that multiplies AL by 2 for 5 iterations.</li>
					</ol>
				</section>

				<section>
					<h2>Pentium Logical Instructions</h2>
					<p>AND, OR, XOR, NOT, TEST</p>
				</section>

				<!-- Slide 2: Logical Instructions Syntax -->
				<section>
					<h3>Syntax</h3>
					<ul>
						<li><code>and destination, source</code></li>
						<li><code>or destination, source</code></li>
						<li><code>xor destination, source</code></li>
						<li><code>not destination</code></li>
					</ul>
					<p>Binary operators: AND, OR, XOR<br>Unary operator: NOT</p>
				</section>

				<!-- Slide 3: Truth Table - AND -->
				<section>
					<h3>AND Operation</h3>
					<table border="1">
						<tr>
							<th>Source</th>
							<th>Dest</th>
							<th>Result</th>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
					</table>
				</section>

				<!-- Slide 4: Truth Table - OR -->
				<section>
					<h3>OR Operation</h3>
					<table border="1">
						<tr>
							<th>Source</th>
							<th>Dest</th>
							<th>Result</th>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>1</td>
						</tr>
					</table>
				</section>

				<!-- Slide 5: Truth Table - XOR -->
				<section>
					<h3>XOR Operation</h3>
					<table border="1">
						<tr>
							<th>Source</th>
							<th>Dest</th>
							<th>Result</th>
						</tr>
						<tr>
							<td>0</td>
							<td>0</td>
							<td>0</td>
						</tr>
						<tr>
							<td>0</td>
							<td>1</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>0</td>
							<td>1</td>
						</tr>
						<tr>
							<td>1</td>
							<td>1</td>
							<td>0</td>
						</tr>
					</table>
				</section>

				<!-- Slide 6: NOT Operation -->
				<section>
					<h3>NOT Operation</h3>
					<p>Unary: flips each bit (bitwise complement)</p>
					<p>Example: <code>AL = 10101110b ‚Üí not AL ‚Üí 01010001b</code></p>
				</section>

				<!-- Slide 7: Logical Instructions Examples -->
				<section>
					<h3>Examples</h3>
					<table border="1">
						<tr>
							<th>Instruction</th>
							<th>AL</th>
							<th>BL</th>
							<th>Result</th>
						</tr>
						<tr>
							<td>AND AL, BL</td>
							<td>1010</td>
							<td>1110</td>
							<td>1010 & 1110 = 1010</td>
						</tr>
						<tr>
							<td>OR AL, BL</td>
							<td>1010</td>
							<td>1110</td>
							<td>1010 | 1110 = 1110</td>
						</tr>
						<tr>
							<td>XOR AL, BL</td>
							<td>1010</td>
							<td>1110</td>
							<td>1010 ^ 1110 = 0100</td>
						</tr>
						<tr>
							<td>NOT AL</td>
							<td>1010</td>
							<td>-</td>
							<td>0101</td>
						</tr>
					</table>
				</section>

				<section>
					<h3>Testing a Bit</h3>
					<pre><code>
; Check LSB of AL
and AL, 01H
jz bit_is_zero
; Code if bit = 1
jmp skip1
bit_is_zero:
; Code if bit = 0
skip1:
; Continue
        </code></pre>
					<p>AND sets ZF flag ‚Üí conditional jump works</p>
				</section>

				<section>
					<h3>Problem</h3>
					<p>AND modifies destination:</p>
					<pre><code>
AL = 10101110b
and AL, 01H ; AL becomes 0 or 1
        </code></pre>
					<p>Original value lost!</p>
				</section>

				<!-- Slide 10: TEST Instruction -->
				<section>
					<h3>TEST Instruction</h3>
					<ul>
						<li>Syntax: <code>test destination, source</code></li>
						<li>Performs bitwise AND without modifying operands</li>
						<li>Sets flags (ZF, SF, PF) like AND</li>
					</ul>
					<pre><code>
test AL, 01H
jz bit_is_zero
        </code></pre>
				</section>

				<section>
					<h3>Exercise</h3>
					<p>Write assembly code to check if the 3rd bit of AL is 1 without modifying AL.</p>
				</section>

				<section>
					<h2>Pentium Shift Instructions</h2>
					<p>SHL (Shift Left) & SHR (Shift Right)</p>
				</section>

				<!-- Slide 2: SHL Instruction -->
				<section>
					<h3>SHL - Shift Left</h3>
					<ul>
						<li>Syntax: <code>shl destination,count</code> or <code>shl destination,CL</code></li>
						<li>Leftmost bit ‚Üí Carry Flag (CF)</li>
						<li>Rightmost bit filled with 0</li>
					</ul>
					<p>Bit movement:</p>
					<pre>7 6 5 4 3 2 1 0 ‚Üí CF</pre>
				</section>

				<!-- Slide 3: SHR Instruction -->
				<section>
					<h3>SHR - Shift Right</h3>
					<ul>
						<li>Syntax: <code>shr destination,count</code> or <code>shr destination,CL</code></li>
						<li>Rightmost bit ‚Üí Carry Flag (CF)</li>
						<li>Leftmost bit filled with 0</li>
					</ul>
					<p>Bit movement:</p>
					<pre>CF ‚Üê 7 6 5 4 3 2 1 0</pre>
				</section>

				<!-- Slide 4: General Rules -->
				<section>
					<h3>Shift Rules</h3>
					<ul>
						<li>Destination can be 8-, 16-, or 32-bit register or memory</li>
						<li>Shift count: 0-31</li>
						<li>CL register can specify count indirectly</li>
						<li>Count > 31 ‚Üí only least significant 5 bits used</li>
						<li>Count of 0 does nothing</li>
					</ul>
				</section>

				<!-- Slide 5: SHL Examples -->
				<section>
					<h3>SHL Examples</h3>
					<table border="1">
						<tr>
							<th>Instruction</th>
							<th>Before</th>
							<th>After</th>
							<th>CF</th>
						</tr>
						<tr>
							<td>shl AL,1</td>
							<td>10101110</td>
							<td>01011100</td>
							<td>1</td>
						</tr>
						<tr>
							<td>mov CL,3<br>shl AL,CL</td>
							<td>01101101</td>
							<td>01101000</td>
							<td>1</td>
						</tr>
					</table>
				</section>

				<!-- Slide 6: SHR Examples -->
				<section>
					<h3>SHR Examples</h3>
					<table border="1">
						<tr>
							<th>Instruction</th>
							<th>Before</th>
							<th>After</th>
							<th>CF</th>
						</tr>
						<tr>
							<td>shr AL,1</td>
							<td>10101110</td>
							<td>01010111</td>
							<td>0</td>
						</tr>
						<tr>
							<td>mov CL,5<br>shr AX,CL</td>
							<td>1011110101011001</td>
							<td>0000010111101010</td>
							<td>1</td>
						</tr>
					</table>
				</section>

				<!-- Slide 7: Checking LSB using SHR -->
				<section>
					<h3>Example: Check Least Significant Bit</h3>
					<pre><code>
shr AL,1
jnc bit_is_zero   ; Jump if CF=0 (LSB was 0)
; Code if bit = 1
jmp skip1
bit_is_zero:
; Code if bit = 0
skip1:
; Continue
        </code></pre>
					<p>Use carry flag (CF) instead of modifying AL.</p>
				</section>

				<!-- Slide 8: Exercise 1 -->
				<section>
					<h3>Exercise 1</h3>
					<p>Given AL = 11010110b:</p>
					<ul>
						<li>Perform <code>shl AL,2</code>. Determine new AL and CF.</li>
						<li>Perform <code>shr AL,3</code>. Determine new AL and CF.</li>
					</ul>
				</section>

				<section>
					<h2>Pentium Rotate Instructions</h2>
					<p>ROL, ROR, RCL, RCR</p>
				</section>

				<!-- Slide 2: Rotate Overview -->
				<section>
					<h3>Why Rotate?</h3>
					<ul>
						<li>Shift instructions lose bits shifted out</li>
						<li>Rotate instructions preserve all bits</li>
						<li>Two types: <strong>Without Carry</strong> and <strong>Through Carry</strong></li>
					</ul>
				</section>

				<!-- Slide 3: Rotate Without Carry -->
				<section>
					<h3>ROL / ROR</h3>
					<ul>
						<li>ROL ‚Üí Rotate Left</li>
						<li>ROR ‚Üí Rotate Right</li>
						<li>Bits shifted out wrap around to the other end</li>
						<li>Syntax: <code>rol dest,count</code>, <code>ror dest,CL</code></li>
					</ul>
					<p>CF catches last bit rotated out</p>
				</section>

				<!-- Slide 4: Visual ROL / ROR -->
				<section>
					<h3>Bit Movement</h3>
					<pre>
ROL: 7 6 5 4 3 2 1 0 ‚Üí wrap to 0
ROR: CF ‚Üê 7 6 5 4 3 2 1 0
        </pre>
				</section>

				<!-- Slide 5: Rotate Without Carry Examples -->
				<section>
					<h3>Examples</h3>
					<table border="1">
						<tr>
							<th>Instruction</th>
							<th>Before</th>
							<th>After</th>
							<th>CF</th>
						</tr>
						<tr>
							<td>rol AL,1</td>
							<td>10101110</td>
							<td>01011101</td>
							<td>1</td>
						</tr>
						<tr>
							<td>ror AL,1</td>
							<td>10101110</td>
							<td>01010111</td>
							<td>0</td>
						</tr>
						<tr>
							<td>mov CL,3<br>rol AL,CL</td>
							<td>01101101</td>
							<td>01101011</td>
							<td>1</td>
						</tr>
					</table>
				</section>

				<!-- Slide 6: Rotate Through Carry -->
				<section>
					<h3>RCL / RCR</h3>
					<ul>
						<li>RCL ‚Üí Rotate Left through Carry</li>
						<li>RCR ‚Üí Rotate Right through Carry</li>
						<li>Bit rotated out ‚Üí CF, CF ‚Üí vacated bit</li>
						<li>Useful for multi-word shifts</li>
						<li>Syntax: <code>rcl dest,count</code>, <code>rcr dest,CL</code></li>
					</ul>
				</section>

				<!-- Slide 7: Visual RCL / RCR -->
				<section>
					<h3>Bit Movement with Carry</h3>
					<pre>
RCL: CF ‚Üí 0 1 2 3 4 5 6 7 ‚Üí CF
RCR: CF ‚Üê 7 6 5 4 3 2 1 0 ‚Üí CF
        </pre>
				</section>

				<!-- Slide 8: Rotate Through Carry Examples -->
				<section>
					<h3>Examples</h3>
					<table border="1">
						<tr>
							<th>Instruction</th>
							<th>Before</th>
							<th>After</th>
							<th>CF</th>
						</tr>
						<tr>
							<td>rcl AL,1</td>
							<td>10101110 0</td>
							<td>01011100</td>
							<td>1</td>
						</tr>
						<tr>
							<td>rcr AL,1</td>
							<td>10101110 1</td>
							<td>11010111</td>
							<td>0</td>
						</tr>
						<tr>
							<td>mov CL,3<br>rcl AL,CL</td>
							<td>01101101 1</td>
							<td>01101101</td>
							<td>1</td>
						</tr>
						<tr>
							<td>mov CL,5<br>rcr AX,CL</td>
							<td>1011110101011001 0</td>
							<td>1001010111101010</td>
							<td>1</td>
						</tr>
					</table>
				</section>

				<!-- Slide 9: Multi-Word Example -->
				<section>
					<h3>64-bit Multiword Shift</h3>
					<pre><code>
; 64-bit number in EDX:EAX
shr EDX,1    ; Move LSB of EDX to CF
rcr EAX,1    ; Insert CF into MSB of EAX
        </code></pre>
					<p>RCR propagates carry between registers for multiword shift</p>
				</section>

				<!-- Slide 10: Exercise 1 -->
				<section>
					<h3>Exercise</h3>
					<p>Given AL = 11010110b, CF = 0:</p>
					<ul>
						<li>Compute <code>rol AL,2</code> ‚Üí new AL, CF</li>
						<li>Compute <code>rcl AL,3</code> ‚Üí new AL, CF</li>
					</ul>
				</section>




			</section>

			<section>
				<section>
					<h2>What is a Stack?</h2>
					<ul>
						<li class="fragment">LIFO ‚Äî Last In, First Out</li>
						<li class="fragment">Two ops: <b>PUSH</b> (insert) and <b>POP</b> (remove)</li>
						<li class="fragment">Only Top-of-Stack (TOS) is directly accessible</li>
					</ul>
				</section>
				<section>
					<h2>Pentium Stack Basics</h2>
					<ul>
						<li class="fragment">Stack segment: <b>SS</b> and top-of-stack offset: <b>ESP</b></li>
						<li class="fragment">Stack grows <b>downward</b> (toward lower addresses)</li>
						<li class="fragment">Only words (16-bit) or dwords (32-bit) are pushed/popped</li>
					</ul>
				</section>

				<section>
					<h3>Visual: Growth & TOS</h3>
					<div class="monoslab small-mono">
						hex addresses ‚Üë<br>
						...<br>
						1003 ‚Üê TOS (top)<br>
						1002<br>
						1001<br>
						1000<br>
					</div>
					<p class="fragment" style="margin-top:14px;">Push 1000 ‚Üí 1001 ‚Üí 1002 ‚Üí 1003. Pop returns 1003 first.
					</p>
				</section>
				<section data-background-color="#0d1117">
					<h4 style="color:#ff9800">x86 Stack Growth on Pentium</h4>
					<div style="display:flex; justify-content:center; gap:80px;">

						<!-- Empty Stack -->
						<div style="text-align:center;">
							<h6 style="color:#42a5f5;">(a) Empty stack</h6>
							<div
								style="background:#111; padding:20px; border-radius:12px; width:140px; height:480px; position:relative;">
								<div style="position:absolute; top:20px; left:-80px; font-size:30px; color:#ffcc80;">TOS
									‚Üí
								</div>
								<div style="position:absolute; top:240px; left:-100px; font-size:25px; color:#ff9800;">
									ESP = 256
								</div>
								<div style="border:3px solid #666; height:400px; margin-top:25px;"></div>
								<div style="margin-top:20px; color:#999;">SS base</div>
							</div>
						</div>

						<!-- After push 21ABh -->
						<div class="fragment" data-fragment-index="1" style="text-align:center;">
							<h6 style="color:#43a047;">(b) After push 21ABh</h6>
							<div
								style="background:#111; padding:20px; border-radius:12px; width:140px; height:480px; position:relative;">
								<div style="position:absolute; top:80px; left:-80px; font-size:30px; color:#ffcc80;">TOS
									‚Üí
								</div>
								<div style="position:absolute; top:240px; left:-100px; font-size:25px; color:#ff9800;">
									ESP = 254
								</div>
								<div
									style="height:40px; background:#1e88e5; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									21</div>
								<div
									style="height:40px; background:#55697a; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									AB</div>
								<div style="border:3px solid #666; height:320px;"></div>
								<div style="margin-top:20px; color:#999;">SS base</div>
							</div>
						</div>

						<!-- After push 7FBD329Ah -->
						<div class="fragment" data-fragment-index="2" style="text-align:center;">
							<h6 style="color:#7b1fa2;">(c) After push 7FBD329Ah</h6>
							<div
								style="background:#111; padding:20px; border-radius:12px; width:140px; height:480px; position:relative;">
								<div style="position:absolute; top:270px; left:-80px; font-size:30px; color:#ffcc80;">
									TOS ‚Üí
								</div>
								<div style="position:absolute; top:360px; left:-100px; font-size:25px; color:#ff9800;">
									ESP = 250
								</div>
								<div
									style="height:40px; background:#1e88e5; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									21</div>
								<div
									style="height:40px; background:#55697a; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									AB</div>
								<div
									style="height:40px; background:#7b1fa2; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									7F</div>
								<div
									style="height:40px; background:#1fa244; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									BD</div>
								<div
									style="height:40px; background:#a2931f; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									32</div>
								<div
									style="height:40px; background:#ce350b; color:white; text-align:center; padding-top:8px; font-size:25px; font-weight:bold;">
									9A</div>
								<div style="border:3px solid #666; height:130px;"></div>
								<div style="margin-top:20px; color:#999;">SS base</div>
							</div>
						</div>
					</div>
				</section>

				<section>
					<h2>PUSH (rules)</h2>
					<p class="fragment">PUSH word: <b>ESP = ESP - 2</b> then store 16-bit at SS:ESP</p>
					<p class="fragment">PUSH dword: <b>ESP = ESP - 4</b> then store 32-bit at SS:ESP</p>
					<pre class="code fragment"><code>push 21ABh    ; 16-bit push
push 7FBD329Ah  ; 32-bit push</code></pre>
				</section>

				<section>
					<h2>POP (rules)</h2>
					<p class="fragment">POP word: dest = SS:ESP ; <b>ESP = ESP + 2</b></p>
					<p class="fragment">POP dword: dest = SS:ESP ; <b>ESP = ESP + 4</b></p>
					<pre class="code fragment"><code>pop AX
pop EAX</code></pre>
				</section>

				<section>
					<h3>Example: Push & Pop</h3>
					<pre class="code small-mono">
; initial ESP = 0100h
push 1234h      ; ESP -> 00FEh ; [00FE] = 34, [00FF] = 12
push 99AB8877h  ; ESP -> 00FAh ; store 32-bit
pop EBX         ; EBX = 99AB8877h ; ESP -> 00FEh
pop AX          ; AX = 1234h ; ESP -> 0100h
      </pre>
				</section>

				<section>
					<h3>Exercise 1 ‚Äî What's the value at TOS?</h3>
					<p>After these pushes, what is stored at TOS?</p>
					<pre class="code small-mono">push 1234h
push 99AB8877h</pre>

					<select id="ex1" style="margin-top:10px;">
						<option value="">Select</option>
						<option value="1234">1234h</option>
						<option value="99ab8877">99AB8877h</option>
						<option value="8877">8877h</option>
					</select>
					<button class="small-btn" id="check-ex1-stack">Check</button>
					<p id="res-ex1" class="result"></p>
				</section>

				<!-- Exercise 2 -->
				<section>
					<h3>Exercise 2 ‚Äî ESP movement</h3>
					<p>Initial: ESP = 2000h</p>
					<p>Instruction: <code>push 55AAh</code></p>
					<p>After execution ESP = ?</p>

					<select id="ex2">
						<option value="">Select</option>
						<option value="2002">2002h</option>
						<option value="1ffe">1FFEh</option>
						<option value="1ffc">1FFCh</option>
					</select>
					<button class="small-btn" id="check-ex2-stack">Check</button>
					<p id="res-ex2" class="result"></p>
				</section>

				<section>
					<h2>Physical Address Calculation</h2>
					<ul>
						<li><strong>Real Mode:</strong> Physical = SS √ó 16 + ESP</li>
						<li><strong>Protected / Flat Mode:</strong> Physical = SS_base + ESP</li>
						<li>In flat memory, SS_base = 0 ‚Üí Physical = ESP</li>
					</ul>
					<p>Example: SS=9000H, ESP=0100H ‚Üí Physical = 90000H + 0100H = 90100H</p>
				</section>

				<!-- Slide 7 -->
				<section>
					<h2>Exercises: Identify TOS Address</h2>
					<p>SS = 8000H, ESP = 0200H ‚Üí TOS = ? (physical address)</p>
				</section>



				<section>
					<h2>Special stack ops</h2>
					<ul>
						<li class="fragment"><b>pushfd / popfd</b> ‚Äî push/pop full EFLAGS (32-bit)</li>
						<li class="fragment"><b>pushfw / popfw</b> ‚Äî 16-bit FLAGS</li>
						<li class="fragment"><b>pushad / popad</b> ‚Äî save/restore all 32-bit GPRs (EAX..EDI)</li>
					</ul>
				</section>

				<section>
					<h3>Protect registers (example)</h3>
					<pre class="code small-mono">
pushad        ; save EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
; ... do work that clobbers regs ...
popad         ; restore (ESP unchanged by popad)
      </pre>
					<p class="fragment" style="color:#4caf50;">Useful at procedure start/end to preserve caller state
					</p>
				</section>


				<section>
					<h3>Exercise 3 ‚Äî Swap registers using stack</h3>
					<p>AX=1234h, BX=5678h. Which sequence swaps them?</p>
					<select id="ex3">
						<option value="">Select</option>
						<option value="a">push AX / pop BX / push BX / pop AX</option>
						<option value="b">push AX / push BX / pop BX / pop AX</option>
						<option value="c">push AX / push BX / pop AX / pop BX</option>
					</select>
					<p style="margin-top:8px;">(Hint: think order of push/pop.)</p>
					<button class="small-btn" id="check-ex3-stack">Check</button>
					<p id="res-ex3" class="result"></p>
				</section>

				<!-- Stack use cases -->
				<section>
					<h2>Common Uses of Stack</h2>
					<ul>
						<li class="fragment">Procedure call return addresses</li>
						<li class="fragment">Passing parameters to procedures</li>
						<li class="fragment">Storing local variables</li>
						<li class="fragment">Saving registers across calls</li>
					</ul>
				</section>

				<!-- Procedure intro -->
				<section>
					<h2>Procedures</h2>
					<p class="fragment">call <b>label</b> ‚Äî pushes return address, jumps to label</p>
					<p class="fragment">ret ‚Äî pops return address into EIP</p>
					<pre class="code fragment"><code>call myfunc
; ... 
; ... 
myfunc:
  ; do work
  ; do work
  ret
</code></pre>
				</section>

				<!-- Example: call/ret -->
				<section>
					<h3>call/ret example</h3>
					<pre class="code small-mono">
main:
  call inc_and_return
  ; EIP resumes here

inc_and_return:
  inc EAX
  ret
      </pre>
				</section>

				<!-- Exercise 4: call stack behavior -->
				<section>
					<h3>Where does RET return?</h3>
					<p>Consider:</p>
					<pre class="code small-mono">
  call L1
  mov EBX, 1
L1:
  ; do stuff
  ret
      </pre>
					<p>After <code>ret</code> executes, next instruction executed is:</p>
					<select id="ex4">
						<option value="">Select</option>
						<option value="mov">mov EBX, 1</option>
						<option value="after">Instruction after mov EBX,1</option>
						<option value="re-exec">Re-execute call L1</option>
					</select>
					<button class="small-btn" id="check-ex4-stack">Check</button>
					<p id="res-ex4" class="result"></p>
				</section>

				<section>
					<h2>How is Program Control Transferred?</h2>
					<p class="fragment">
						The CALL instruction does not use an absolute offset.
					</p>
					<p class="fragment">
						It uses a relative displacement from the next instruction.
					</p>
					<p class="fragment">Example:</p>
				</section>


				<section>
					<h3>Machine Code Example</h3>
					<pre><code class="hljs" data-trim>
offset          machine code
(in hex)        (in hex)

                								main:
00000002        E816000000      call    sum
00000007        89C3            mov     EBX,EAX

                ; end of main procedure


                								sum:
0000001D        55              push    EBP

                ; end of sum procedure


                								avg:
00000028        E8F0FFFFFF      call    sum
0000002D        89D8            mov     EAX,EBX

                ; end of avg procedure
                </code></pre>
				</section>

				<section>
					<h3>After the CALL Instruction in main</h3>
					<p class="fragment">
						After executing <span class="highlight">CALL</span>, EIP moves to the next instruction.
					</p>
					<p class="fragment">
						Here, EIP becomes <b>00000007H</b>.
					</p>
					<p class="fragment">
						This address is where execution will continue after <b>sum</b> finishes.
					</p>
					<p class="fragment">
						<b>The processor saves this address by pushing EIP onto the stack.</b>
					</p>
				</section>


				<section>
					<h3>Transfer Control to sum</h3>
					<p class="fragment">
						Control jumps to the first instruction of <b>sum</b>.
					</p>
					<pre class="fragment"><code>push EBP</code></pre>
					<p class="fragment">
						New EIP = current EIP + CALL displacement.
					</p>
				</section>


				<section>
					<h3>Understanding the Encoding</h3>
					<p class="fragment">
						The <b>CALL</b> instruction uses <b>5 bytes</b>.
					</p>
					<pre class="fragment"><code>E8 16 00 00 00</code></pre>
					<ul>
						<li class="fragment"><b>E8</b> ‚Üí opcode for CALL</li>
						<li class="fragment"><b>16 00 00 00</b> ‚Üí relative displacement</li>
					</ul>
				</section>

				<section>
					<h3>Calculating the Displacement</h3>
					<p class="fragment">
						Displacement = target ‚àí next instruction
					</p>
					<pre class="fragment"><code>
Target (sum)      = 0000001D
Next instruction  = 00000007
Displacement      = 00000016
  </code></pre>
				</section>



				<section>
					<h3>Notes on the Example</h3>
					<p class="fragment">
						The displacement is stored in <b>little-endian</b>(LSB first) format.
					</p>
					<pre class="fragment"><code>16 00 00 00</code></pre>
				</section>

				<section>
					<h3>Backward Procedure Call</h3>
					<p class="fragment">
						In <b>avg</b>, CALL <b>sum</b> jumps backward.
					</p>
					<p class="fragment">
						Target address &lt; next instruction ‚Üí negative displacement.
					</p>
					<pre class="fragment"><code>
Displacement = 0000001D - 0000002D
             = FFFFFFF0H
             = -16D
    </code></pre>
				</section>

				<section>
					<h3>2's Complement Representation</h3>
					<p class="fragment">
						Negative displacements are stored in <b>2's complement</b>.
					</p>
					<p class="fragment">
						FFFFFFF0H represents <b>-16 decimal</b>.
					</p>
				</section>

				<section>
					<h3>Stack Action During CALL</h3>
					<p class="fragment">
						Return address is pushed onto the stack.
					</p>
					<pre class="fragment"><code>
ESP = ESP - 4
SS:ESP = EIP
    </code></pre>
				</section>

				<section>
					<h3>Updating EIP</h3>
					<p class="fragment">
						EIP = EIP + relative displacement
					</p>
					<p class="fragment">
						Signed 32-bit displacement allows <b>forward & backward calls</b>.
					</p>
				</section>

				<section>
					<h3>Summary of Near CALL</h3>
					<ul class="fragment">
						<li>Push return address onto stack</li>
						<li>Compute displacement (target ‚àí next instruction)</li>
						<li>Update EIP with displacement</li>
						<li>Displacement is signed 32-bit</li>
					</ul>
				</section>
				<section>
					<h3>Exercise: Understanding Near CALL and Return Address</h3>
					<p>Study the following machine code layout carefully.</p>
					<pre><code class="hljs" data-trim>
offset          machine code
(in hex)        (in hex)

                								start:
00000000        xxxxxxxxxx      call    calculate
00000005        89C2            mov     EDX,EAX

                ; end of start procedure


                								calculate:
00000012        55              push    EBP
00000013        8B55 08         mov     EDX,[EBP+8]
00000016        03C2            add     EAX,EDX
                								; ... more instructions ...

                								finish:
00000030        xxxxxxxxxx      call    calculate
00000035        F7D8            neg     EAX

                ; end of finish procedure
                </code></pre>
				</section>

				<section>
					<h3>Question 1: Return Address After CALL in <code>start</code></h3>
					<p>When the CALL at offset <code>00000000</code> is executed, what address is pushed onto the stack
						as the
						return address?</p>
					<p class="fragment">This is the address of the instruction that should be executed when
						<code>calculate</code> returns.
					</p>

					<input id="tc-ex1-q1" type="text" placeholder="Enter address in hex, e.g. 00000005"
						style="width: 300px; font-family: monospace;">
					<button onclick="checkTCEx1Q1()">Check Answer</button>
					<p id="tc-ex1-q1-feedback" style="margin-top: 10px; font-weight: bold;"></p>

					<script>
						function checkTCEx1Q1() {
							const input = document.getElementById('tc-ex1-q1').value.trim().toUpperCase().replace(/H$/, '');
							const feedback = document.getElementById('tc-ex1-q1-feedback');
							const correct = ['00000005', '5', '00000005H', '5H'];
							if (correct.some(c => c === input)) {
								feedback.textContent = 'Correct! The next instruction after the 5-byte CALL is at 00000005.';
								feedback.style.color = 'green';
							} else {
								feedback.textContent = 'Incorrect. Hint: The CALL instruction is 5 bytes long.';
								feedback.style.color = 'red';
							}
						}
					</script>
				</section>

				<section>
					<h4>Machine Code for the Forward CALL</h4>
					<p>The near CALL instruction has the opcode <code>E8</code> and uses a 32-bit relative displacement
						(5 bytes
						total).</p>
					<p>What is the complete machine code (in hexadecimal) for the <code>call calculate</code>
						instruction at
						offset <code>00000000</code>?</p>
					<p class="fragment">Hint: First byte is the opcode, followed by the 4-byte displacement in
						little-endian
						order.</p>

					<input id="tc-ex1-q2" type="text" placeholder="e.g. E81E000000"
						style="width: 300px; font-family: monospace;">
					<button onclick="checkTCEx1Q2()">Check Answer</button>
					<p id="tc-ex1-q2-feedback" style="margin-top: 10px; font-weight: bold;"></p>

					<script>
						function checkTCEx1Q2() {
							const input = document.getElementById('tc-ex1-q2').value.trim().toUpperCase().replace(/ /g, '');
							const feedback = document.getElementById('tc-ex1-q2-feedback');
							const correct = ['E81E000000', 'E8 1E 00 00 00'];
							if (correct.some(c => input === c || input === c.replace(/ /g, ''))) {
								feedback.textContent = 'Correct!';
								feedback.style.color = 'green';
							} else {
								feedback.textContent = 'Wrong. displacement -> little-endian after E8.';
								feedback.style.color = 'red';
							}
						}
					</script>
				</section>

				<section>
					<h4>Backward CALL in <code>finish</code></h4>
					<p>If the near CALL instruction has the opcode <code>E8</code> and uses a 32-bit relative
						displacement, then find the the complete machine code (in hexadecimal) for the
						<code>call calculate</code> instruction at
						offset <code>00000030</code>?
					</p>
					<p class="fragment">Hint: First byte is the opcode, followed by the 4-byte displacement in
						little-endian
						order.</p>

					<input id="tc-ex1-q3" type="text" placeholder="e.g. E8DDFFFFFF"
						style="width: 300px; font-family: monospace;">
					<button onclick="checkTCEx1Q3()">Check Answer</button>
					<p id="tc-ex1-q3-feedback" style="margin-top: 10px; font-weight: bold;"></p>

					<script>
						function checkTCEx1Q3() {
							const input = document.getElementById('tc-ex1-q3').value.trim().toUpperCase().replace(/ /g, '');
							const feedback = document.getElementById('tc-ex1-q3-feedback');
							const correct = ['E8DDFFFFFF', 'E8 DD FF FF FF'];
							if (correct.some(c => input === c || input === c.replace(/ /g, ''))) {
								feedback.textContent = 'Correct!';
								feedback.style.color = 'green';
							} else {
								feedback.textContent = 'Wrong. displacement -> little-endian after E8.';
								feedback.style.color = 'red';
							}
						}
					</script>
				</section>


				<section>
					<h3>Question 4: Multiple Choice ‚Äì What happens during a near CALL?</h3>
					<p>Select <strong>all</strong> correct actions that occur when a near CALL executes.</p>

					<form id="tc-ex1-q4-form" style="font-size: 0.8em; line-height: 1.6;">
						<label><input type="checkbox" name="opt" value="1"> 1. The return address (next instruction) is
							pushed
							onto the stack</label><br>
						<label><input type="checkbox" name="opt" value="2"> 2. EIP is set to the absolute address of the
							target
							procedure</label><br>
						<label><input type="checkbox" name="opt" value="3"> 3. A signed 32-bit displacement is added to
							the
							current EIP</label><br>
						<label><input type="checkbox" name="opt" value="4"> 4. The flags register is saved on the
							stack</label><br>
						<label><input type="checkbox" name="opt" value="5"> 5. ESP is decremented by 4 before pushing
							the return
							address</label><br>
					</form>

					<button onclick="checkTCEx1Q4()">Check Answers</button>
					<p id="tc-ex1-q4-feedback" style="margin-top: 10px; font-weight: bold;"></p>

					<script>
						function checkTCEx1Q4() {
							const checks = document.querySelectorAll('#tc-ex1-q4-form input[type="checkbox"]');
							const selected = Array.from(checks).filter(c => c.checked).map(c => c.value);
							const feedback = document.getElementById('tc-ex1-q4-feedback');
							const correct = ['1', '3', '5'];  // 1,3,5 are correct

							const correctSet = new Set(correct);
							const selectedSet = new Set(selected);

							if (selected.length === correct.length && selected.every(v => correctSet.has(v))) {
								feedback.textContent = 'Perfect! All correct choices selected.';
								feedback.style.color = 'green';
							} else {
								feedback.textContent = 'Not quite. Review what happens on a near CALL.';
								feedback.style.color = 'red';
							}
						}
					</script>
				</section>
				<section>
					<h3>Procedure Call</h3>

					<ul>
						<li>A procedure (function) is a reusable block of code</li>
						<li>The <code>call</code> instruction jumps to the function</li>
						<li><code>call</code> also saves the return address on the stack</li>
					</ul>

					<pre>
call sum
‚Üì
return address pushed
  </pre>
				</section>
				<section>
					<h3>Creating a Stack Frame</h3>

					<ul>
						<li>The callee saves the old base pointer</li>
						<li>A new stack frame is created</li>
						<li><code>EBP</code> becomes the reference point</li>
					</ul>

					<pre><code class="language-asm">
push ebp
mov  ebp, esp
  </code></pre>
				</section>

				<section>
					<h3>Inside the Stack Frame</h3>

					<pre>
Higher Memory
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ function arguments ‚îÇ ‚Üê [EBP + 8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ return address     ‚îÇ ‚Üê [EBP + 4]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP          ‚îÇ ‚Üê [EBP]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory
  </pre>

					<p><small>
							Stack grows downward
						</small></p>
				</section>


				<section>
					<h3>An example C Function</h3>

					<pre><code class="language-c">
int sum(int x, int y)
{
    return (x + y);
}
  </code></pre>

					<p><small>
							Two parameters, returns their sum
						</small></p>
				</section>
				<section>
					<h3>Stack Frame for <code>sum(int x, int y)</code></h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ y                       ‚îÇ ‚Üê [EBP + 12]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ x                       ‚îÇ ‚Üê [EBP + 8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ return address          ‚îÇ ‚Üê [EBP + 4]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP               ‚îÇ ‚Üê [EBP]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
  </pre>

					<p><small>
							Stack grows downward (toward lower addresses)
						</small></p>
				</section>


				<section>
					<h3>x86 Assembly</h3>

					<pre><code class="language-asm">
sum:
    push ebp            ; save caller's base pointer
    mov  ebp, esp       ; establish new stack frame

    mov  eax, [ebp+8]   ; load x
    add  eax, [ebp+12]  ; add y

    pop  ebp            ; restore caller's frame
    ret                 ; return (result in EAX)
  </code></pre>

					<p><small>
							Return value is placed in <b>EAX</b>
						</small></p>
				</section>

				<section>
					<h3>An example C Function (with local variables)</h3>

					<pre><code class="language-c">
int sum_local(int x, int y)
{
    int temp;
    temp = x + y;
    return temp;
}
	</code></pre>

					<p><small>
							Two parameters, one local variable
						</small></p>
				</section>

				<section>
					<h3>Stack Frame for <code>sum_local(int x, int y)</code></h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ y                       ‚îÇ ‚Üê [EBP + 12]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ x                       ‚îÇ ‚Üê [EBP + 8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ return address          ‚îÇ ‚Üê [EBP + 4]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP               ‚îÇ ‚Üê [EBP]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ temp (local variable)   ‚îÇ ‚Üê [EBP - 4]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
	</pre>

					<p><small>
							Local variables are stored at negative offsets from EBP
						</small></p>
				</section>

				<section>
					<h3>x86 Assembly (32-bit, cdecl, with local variable)</h3>

					<pre><code class="language-asm">
sum_local:
    push ebp              ; save caller's base pointer
    mov  ebp, esp         ; establish new stack frame
    sub  esp, 4           ; allocate space for temp

    mov  eax, [ebp+8]     ; load x
    add  eax, [ebp+12]    ; add y
    mov  [ebp-4], eax     ; store result in temp

    mov  eax, [ebp-4]     ; move temp to EAX (return value)

    mov  esp, ebp         ; deallocate locals
    pop  ebp              ; restore caller's frame
    ret                   ; return
	</code></pre>

					<p><small>
							Local variables use stack space below EBP
						</small></p>
				</section>


				<section>
					<h3>Two Functions</h3>

					<pre><code class="language-c">
int add(int a, int b)
{
    int t;
    t = a + b;
    return t;
}

int main()
{
    int r;
    r = add(3, 4);
    return 0;
}
	</code></pre>
				</section>

				<section>
					<h3>main() Stack Frame</h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ return address to OS    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP (caller)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (main)
‚îÇ r  (local variable)     ‚îÇ ‚Üê [EBP - 4]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
	</pre>
				</section>

				<section>
					<h3>Arguments Pushed (right ‚Üí left)</h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ return address to OS    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP (caller)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (main)
‚îÇ r                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 4  (b)                  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 3  (a)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
	</pre>
				</section>

				<section>
					<h3>CALL add</h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ return address to OS    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP (caller)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (main)
‚îÇ r                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 4                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 3                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ return addr to main     ‚îÇ ‚Üê pushed by CALL
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
	</pre>
				</section>

				<section>
					<h3>add() Prologue</h3>

					<pre><code class="language-asm">
push ebp
mov  ebp, esp
sub  esp, 4      ; local variable t
	</code></pre>
				</section>


				<section>
					<h3>add() Stack Frame</h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ b                       ‚îÇ ‚Üê [EBP + 12]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ a                       ‚îÇ ‚Üê [EBP + 8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ return addr to main     ‚îÇ ‚Üê [EBP + 4]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP (main)        ‚îÇ ‚Üê [EBP]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ t  (local variable)     ‚îÇ ‚Üê [EBP - 4]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
	</pre>
				</section>


				<section>
					<h3>add() Execution</h3>

					<pre><code class="language-asm">
mov eax, [ebp+8]
add eax, [ebp+12]
mov [ebp-4], eax
	</code></pre>

					<p><small>
							Result stored in EAX
						</small></p>
				</section>

				<section>
					<h3>add() Epilogue</h3>

					<pre><code class="language-asm">
mov esp, ebp
pop ebp
ret
	</code></pre>
				</section>

				<section>
					<h3>Back in main()</h3>

					<pre>
Higher Memory Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ return address to OS    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP (caller)      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (main)
‚îÇ r = EAX                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Memory Addresses
	</pre>
				</section>


				<section>
					<h3>What Happened</h3>

					<ul>
						<li>Stack grows from high ‚Üí low</li>
						<li>Each function creates its own frame</li>
						<li>EBP anchors, ESP moves</li>
						<li>CALL pushes return address</li>
						<li>RET restores control</li>
					</ul>
				</section>


				<section>
					<h1>Dive deep</h1>
				</section>

				<section>
					<h3>Execution Step 1</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
    m = x * y;
    return m;
}

int func()
{
‚û°   int r;
    r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
Higher Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ret ‚Üí caller  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (func)
‚îÇ r             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Addresses
</pre>
						</div>

					</div>
				</section>


				<section>
					<h3>Execution Step 2</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
    m = x * y;
    return m;
}

int func()
{
    int r;
‚û°   r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
Higher Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ret ‚Üí caller  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (func)
‚îÇ r             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 5             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Addresses
</pre>
						</div>

					</div>
				</section>


				<section>
					<h3>Execution Step 3</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
    m = x * y;
    return m;
}

int func()
{
    int r;
‚û°   r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
Higher Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ret ‚Üí caller  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (func)
‚îÇ r             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 5             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ret ‚Üí func    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Addresses
</pre>
						</div>

					</div>
				</section>


				<section>
					<h3>Execution Step 4</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
‚û°   int m;
    m = x * y;
    return m;
}

int func()
{
    int r;
    r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
Higher Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ y             ‚îÇ ‚Üê [EBP+12]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ x             ‚îÇ ‚Üê [EBP+8]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ret ‚Üí func    ‚îÇ ‚Üê [EBP+4]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP     ‚îÇ ‚Üê [EBP]
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ m             ‚îÇ ‚Üê [EBP-4]
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Addresses
</pre>
						</div>

					</div>
				</section>


				<section>
					<h3>Execution Step 5</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
‚û°   m = x * y;
    return m;
}

int func()
{
    int r;
    r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
m = 10
EAX = 10
</pre>
						</div>

					</div>
				</section>


				<section>
					<h3>Execution Step 6</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
    m = x * y;
‚û°   return m;
}

int func()
{
    int r;
    r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
mul() frame destroyed
Return value in EAX
</pre>
						</div>

					</div>
				</section>



				<section>
					<h3>Execution Step 7</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
    m = x * y;
    return m;
}

int func()
{
    int r;
‚û°   r = mul(2, 5);
    return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
Higher Addresses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ret ‚Üí caller  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ saved EBP     ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê EBP (func)
‚îÇ r = 10        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Lower Addresses
</pre>
						</div>

					</div>
				</section>









				<section>
					<h3>Execution Step 8</h3>

					<div style="display:flex; gap:40px;">

						<div style="width:50%;">
							<pre><code class="language-c">
int mul(int x, int y)
{
    int m;
    m = x * y;
    return m;
}

int func()
{
    int r;
    r = mul(2, 5);
‚û°   return r;
}
</code></pre>
						</div>

						<div style="width:50%;">
							<pre>
Stack
All frames removed
Execution complete
</pre>
						</div>

					</div>
				</section>


				<section>
					<h2>Procedure: Sum of Three Numbers</h2>
					<p>Write a procedure <strong>sum3</strong> that receives three integers and returns their sum.</p>
					<pre><code>
int sum3(int a, int b, int c) {
    return a + b + c;
}
    </code></pre>
				</section>

				<section>
					<h2>Assembly: Sum of Three Numbers</h2>
					<pre><code>
sum3:               ; sum3(a, b, c)
    push    ebp
    mov     ebp, esp

    mov     ax, [ebp + 8]   ; a
    add     ax, [ebp + 12]  ; + b
    add     ax, [ebp + 16]  ; + c

    pop     ebp
    ret
    </code></pre>
				</section>

				<section>
					<h2>Procedure: Maximum of Two Numbers</h2>
					<p>Write a procedure <strong>max2</strong> that receives two integers and returns the maximum.</p>
					<pre><code>
int max2(int a, int b) {
    if (a &gt;= b) return a;
    else return b;
}
    </code></pre>
				</section>

				<section>
					<h2>Assembly: Maximum of Two Numbers</h2>
					<pre><code>
max2:               ; max2(a, b)
    push    ebp
    mov     ebp, esp

    mov     ax, [ebp + 8]   ; a
    cmp     ax, [ebp + 12]  ; compare with b
    jl      use_b           ; if a &lt; b, use b
    jmp     done

use_b:
    mov     ax, [ebp + 12]  ; AX = b

done:
    pop     ebp
    ret
    </code></pre>
				</section>






				<section>
					<h2>Procedure: Find Maximum of Three Numbers</h2>
					<p>Write a procedure <strong>max</strong> that receives three integers from <em>main</em> and
						returns the maximum in <strong>AX</strong>.</p>

					<h3>Example in C</h3>
					<pre><code>
int max(int a, int b, int c) {
    if (a &gt;= b && a &gt;= c) return a;
    else if (b &gt;= c) return b;
    else return c;
}
    </code></pre>
				</section>


				<section>
					<h2>Assembly: Procedure max</h2>
					<pre><code>
max:                ; label marking start of procedure
    push    ebp
    mov     ebp, esp

    mov     ax, [ebp + 8]   ; a
    cmp     ax, [ebp + 12]  ; b
    jl      check_b
    cmp     ax, [ebp + 16]  ; c
    jl      load_c
    jmp     done

check_b:
    mov     ax, [ebp + 12]  ; b
    cmp     ax, [ebp + 16]  ; c
    jl      load_c

done:
    pop     ebp
    ret

load_c:
    mov     ax, [ebp + 16]  ; c
    jmp     done

    </code></pre>
				</section>

				<section>
					<h2>Procedure: Count String Length</h2>
					<p>Use a loop to count the number of characters in a NULL-terminated string.</p>
					<pre><code>
int strlen_loop(char *str) {
    int len = 0;
    while (str[len] != '\0') {
        len++;
    }
    return len;
}
    </code></pre>
				</section>


				<section>
					<h2>Assembly: Count String Length</h2>
					<pre><code>
strlen_loop:              ; strlen_loop(str)
    push    ebp
    mov     ebp, esp

    mov     esi, [ebp + 8]   ; ESI = pointer to string
    xor     cx, cx            ; CX = counter (length)

count_loop:
    mov     al, [esi + cx]   ; load current character
    cmp     al, 0
    je      done             ; exit loop if NULL
    inc     cx               ; increment counter
    jmp     count_loop

done:
    mov     ax, cx           ; return length in AX
    pop     ebp
    ret
    </code></pre>
				</section>
				<section>
					<h2>Sum Function: C vs Assembly</h2>
					<div style="display: flex; gap: 50px;">
						<!-- Left: C Code -->
						<div style="flex: 1; padding: 10px; border-radius: 5px;">
							<pre><code>int sum(int x, int y)
{
    int s;
    s = x + y;
    return s;
}

int func()
{
    int r;
    r = sum(2, 5);
    return r;
}</code></pre>
						</div>

						<!-- Right: Assembly Code -->
						<div style="flex: 1; padding: 10px; border-radius: 5px;">
							<pre><code>sum:
    push ebp
    mov ebp, esp
    sub esp, 4          ; allocate local s

    mov eax, [ebp+8]    ; eax = x
    add eax, [ebp+12]   ; eax += y
    mov [ebp-4], eax    ; store in s

    mov eax, [ebp-4]    ; return s

    mov esp, ebp        ; restore esp before return
    pop ebp
    ret


func:
    push ebp
    mov ebp, esp
    sub esp, 4          ; allocate space for local int r (4 bytes)

    push 5              ; second argument (y)
    push 2              ; first argument (x)
    call sum
    add esp, 8          ; clean up arguments

    mov [ebp-4], eax    ; store return value into r (local variable)

    mov eax, [ebp-4]    ; load r back into eax for return
    mov esp, ebp        ; deallocate local
    pop ebp
    ret</code></pre>
						</div>
					</div>
				</section>

				<!-- Practice problems -->
				<section>
					<h2>Practice Problems</h2>
					<ol>
						<li class="fragment">Write code to push EAX, EBX, ECX then pop into ESI, EDI, EBP (order
							matters).</li>
						<li class="fragment">Write a small procedure that increments a memory cell N times using LOOP.
						</li>
						<li class="fragment">Show how to pass two 32-bit args on the stack and return a 32-bit result in
							EAX.</li>
					</ol>
				</section>

				<!-- Summary -->
				<section>
					<h2>Summary (Quick)</h2>
					<ul>
						<li class="fragment">Stack = LIFO; SS:ESP points to TOS</li>
						<li class="fragment">PUSH/POP adjust ESP by 2 or 4</li>
						<li class="fragment">pushad/popad and pushfd/popfd are convenience ops</li>
						<li class="fragment">Used heavily in procedure calls & parameter passing</li>
					</ul>
				</section>

				<script>
					// Interactive checks (safe: wait until DOM ready)
					document.addEventListener('DOMContentLoaded', () => {
						// Exercise 1
						document.getElementById('check-ex1-stack').addEventListener('click', () => {
							const v = document.getElementById('ex1').value;
							const r = document.getElementById('res-ex1');
							if (v === '99ab8877') { r.textContent = 'Correct ‚Äî TOS = 99AB8877h'; r.style.color = 'green'; }
							else { r.textContent = 'Wrong ‚Äî TOS is the last pushed item (99AB8877h)'; r.style.color = 'red'; }
						});

						// Exercise 2
						document.getElementById('check-ex2-stack').addEventListener('click', () => {
							const v = document.getElementById('ex2').value;
							const r = document.getElementById('res-ex2');
							if (v === '1ffe') { r.textContent = 'Correct ‚Äî ESP decreases by 2'; r.style.color = 'green'; }
							else { r.textContent = 'Incorrect ‚Äî PUSH word subtracts 2 from ESP'; r.style.color = 'red'; }
						});

						// Exercise 3 (swap using stack) ‚Äî correct pattern: push AX ; push BX ; pop AX ; pop BX is WRONG.
						// The correct swap using stack: push AX ; push BX ; pop AX? -> explain: easiest: push AX; push BX; pop AX? Not trivial in selects.
						// We'll accept answer 'a' only if user picks the right one (construct simple correct option: push AX ; push BX ; pop AX ; pop BX will leave original order)
						// Provide correct explanation: correct sequence to swap using stack: push AX; push BX; pop AX_temp? Simpler: push AX; push BX; pop AX ; pop BX DOES NOT SWAP.
						// We'll give the simplest correct sequence: push AX ; push BX ; pop AX ; pop BX -> this actually restores original order ‚Äî so let's mark option 'a' as correct if it's the intended mistaken option? To avoid confusion, make "c" the correct simple swap:
						// Correct swap using stack (simple): push AX ; push BX ; pop AX ; pop BX (No ‚Äî that's incorrect). Proper swap using push/pop:
						// push AX
						// push BX
						// pop AX   ; AX = old BX
						// pop BX   ; BX = old AX
						// This actually swaps. So option c is the same as b; ensure one option matches that. We'll accept option 'c'.
						document.getElementById('check-ex3-stack').addEventListener('click', () => {
							const v = document.getElementById('ex3').value;
							const r = document.getElementById('res-ex3');
							if (v === 'c') {
								r.textContent = 'Correct ‚Äî push AX; push BX; pop AX; pop BX swaps AX and BX'; r.style.color = 'green';
							} else {
								r.textContent = 'Not quite ‚Äî think: last pushed becomes first popped. Push AX then BX ‚Üí pop gives BX then AX (swapped)'; r.style.color = 'red';
							}
						});

						// Exercise 4
						document.getElementById('check-ex4-stack').addEventListener('click', () => {
							const v = document.getElementById('ex4').value;
							const r = document.getElementById('res-ex4');
							if (v === 'mov') { r.textContent = 'Correct ‚Äî RET returns to instruction after the CALL, which is mov EBX, 1'; r.style.color = 'green'; }
							else { r.textContent = 'Incorrect ‚Äî RET pops return address produced by CALL (next instruction after call)'; r.style.color = 'red'; }
						});

					});
				</script>

			</section>










		</div>
	</div>



	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		Reveal.initialize({
			hash: true,
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
		// Custom script to show interconnect circle with fragment
		Reveal.addEventListener('fragmentshown', function (event) {
			if (event.fragment.classList.contains('interconnect')) {
				event.fragment.style.display = 'block';
			}
		});
	</script>
</body>

</html>